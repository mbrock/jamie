<!doctype html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Aider Chronicle</title><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=DM+Mono&amp;family=DM+Sans:ital,opsz,wght@0,9..40,100..1000;1,9..40,100..1000&amp;display=swap" rel="stylesheet"><style>
				:root {
					--bg-color: #ffffff;
					--text-color: #333333;
					--link-color: #0066cc;
					--link-hover-color: #004499;
					--color-border: #eee;
				}
				@media (prefers-color-scheme: dark) {
					:root {
						--bg-color: #1a1a1a;
						--text-color: #e0e0e0;
						--link-color: #4da6ff;
						--link-hover-color: #80bfff;
						--color-border: #333;
					}
				}
				body {
					font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
					line-height: 1.4;
					color: var(--text-color);
					background-color: var(--bg-color);
					margin: 0 auto;
					padding: 20px;
				}
				pre, tt, code, kbd, samp, .mono {
					font-family: "DM Mono", monospace;
					font-weight: 400;
					font-style: normal;
				}
				a {
					color: var(--link-color);
					text-decoration: none;
				}
				a:hover {
					color: var(--link-hover-color);
					text-decoration: underline;
				}
				h1, h2, h3, h4, h5, h6 {
					margin-top: 1.5em;
					margin-bottom: 0.5em;
				}
			</style></head><body><style>
			body {
				line-height: 1.6;
				color: var(--text-color);
				background-color: var(--bg-color);
				margin: 0;
				padding: 20px;
				box-sizing: border-box;
			}

			@media (min-width: 1024px) {
				body {
					height: 100vh;
					column-width: 50ch;
					column-fill: auto;
				}
			}

			.date {
				font-size: 1.2em;
				font-weight: bold;
				margin: 2rem 0 1rem;
				color: var(--text-color);
				opacity: 0.8;
				width: 100%;
			}
			.entry {
				display: flex;
				align-items: baseline;
				padding: 0 .5rem;
				margin: .25rem 0;
				max-width: 62ch;
			}
			.entry-timestamp {
				font-size: 0.8em;
				opacity: 0.6;
				margin-right: 10px;
			}
			.entry-type {
				font-weight: bold;
				font-size: 0.9em;
				margin-right: 5px;
				font-family: 'DM Mono', monospace;
			}
			.entry-content {
				white-space: pre-wrap;
			}
			.keyboard .entry-content {
				font-family: 'DM Mono', monospace;
			}
			.voice .entry-content {
				font-style: italic;
			}
			tt {
				padding: 0px 4px;
				letter-spacing: -.5px;
				background-color: var(--color-border);
				border-radius: 3px;
			}
		</style><div class="date">Friday, 2 August</div><span class="entry code"><span class="entry-timestamp">00:08</span> <span class="entry-type">&gt;</span> <span class="entry-content">i want to save the opus packets in nats jetstreams</span></span><span class="entry code"><span class="entry-timestamp">01:00</span> <span class="entry-type">&gt;</span> <span class="entry-content">maybe we want to store this stuff in postgres instead</span></span><span class="entry code"><span class="entry-timestamp">01:01</span> <span class="entry-type">&gt;</span> <span class="entry-content">also create the tables</span></span><span class="entry code"><span class="entry-timestamp">01:01</span> <span class="entry-type">&gt;</span> <span class="entry-content">use embed instead</span></span><span class="entry code"><span class="entry-timestamp">01:14</span> <span class="entry-type">&gt;</span> <span class="entry-content">refactor <tt>main.go</tt> so the handlers aren&#39;t just closures but methods on a struct</span></span><span class="entry code"><span class="entry-timestamp">01:26</span> <span class="entry-type">&gt;</span> <span class="entry-content">make a table for voice state events, insert in <tt>VoiceStateUpdate</tt> </span></span><span class="entry code"><span class="entry-timestamp">01:32</span> <span class="entry-type">&gt;</span> <span class="entry-content">make a table for discord sessions with the bot token, user id, created at</span></span><span class="entry code"><span class="entry-timestamp">01:35</span> <span class="entry-type">&gt;</span> <span class="entry-content">add columns to <tt>opus_packets</tt> and <tt>ssrc_mappings</tt> that link to <tt>discord_sessions</tt></span></span><span class="entry code"><span class="entry-timestamp">01:37</span> <span class="entry-type">&gt;</span> <span class="entry-content">keep the session id in the Bot struct</span></span><span class="entry code"><span class="entry-timestamp">01:49</span> <span class="entry-type">&gt;</span> <span class="entry-content">turn <tt>main.go</tt> into a cobra cli app with the current main as the command &#34;jamie listen&#34;</span></span><span class="entry code"><span class="entry-timestamp">01:56</span> <span class="entry-type">&gt;</span> <span class="entry-content">we should save a db row when we join a channel so that we can rejoin it when we restart the bot</span></span><span class="entry code"><span class="entry-timestamp">01:59</span> <span class="entry-type">&gt;</span> <span class="entry-content">do the joining of the latest channel upon receiving the guild event</span></span><span class="entry code"><span class="entry-timestamp">02:00</span> <span class="entry-type">&gt;</span> <span class="entry-content">no it should just rejoin the latest channel that it itself has joined as that bot</span></span><span class="entry code"><span class="entry-timestamp">02:00</span> <span class="entry-type">&gt;</span> <span class="entry-content">i think we can join one voice call per guild?</span></span><span class="entry code"><span class="entry-timestamp">02:01</span> <span class="entry-type">&gt;</span> <span class="entry-content">do the joining in the <tt>GuildCreate</tt> handler instead</span></span><span class="entry ask"><span class="entry-timestamp">02:16</span> <span class="entry-type">?</span> <span class="entry-content">with this postgres table structure, is there some way for another program connected to the database to listen for new packets, etc?</span></span><span class="entry code"><span class="entry-timestamp">02:16</span> <span class="entry-type">&gt;</span> <span class="entry-content">do something like that with a new cobra command that just print some info about each new packet</span></span><span class="entry code"><span class="entry-timestamp">02:32</span> <span class="entry-type">&gt;</span> <span class="entry-content">make the packets command print less verbosely but also print the number of milliseconds elapsed since last print</span></span><span class="entry code"><span class="entry-timestamp">02:34</span> <span class="entry-type">&gt;</span> <span class="entry-content">make it print average/min/max elapsed so we can see like variance in how long the notify handling takes or whatever</span></span><span class="entry code"><span class="entry-timestamp">02:37</span> <span class="entry-type">&gt;</span> <span class="entry-content">get rid of the elapsed stuff, it&#39;s too complex</span></span><span class="entry code"><span class="entry-timestamp">02:48</span> <span class="entry-type">&gt;</span> <span class="entry-content">make a command that takes a time range, defaulting to between ten minutes ago and now, selects packets in that range from some given ssrc, and print some info</span></span><span class="entry code"><span class="entry-timestamp">02:50</span> <span class="entry-type">&gt;</span> <span class="entry-content">maybe an index would be useful</span></span><span class="entry code"><span class="entry-timestamp">02:57</span> <span class="entry-type">&gt;</span> <span class="entry-content">when you loop over the packets, if you see a timestamp increase of more than 960 20ms that means there&#39;s a gap in the audio due to silence, print some info about that</span></span><span class="entry code"><span class="entry-timestamp">03:01</span> <span class="entry-type">&gt;</span> <span class="entry-content">now make it generate an ogg container for those packets, inserting empty 20ms frames when necessary, using pion&#39;s oggwriter</span></span><span class="entry code"><span class="entry-timestamp">03:03</span> <span class="entry-type">&gt;</span> <span class="entry-content">use github.com/pion/webrtc/v4/pkg/media/oggwriter, func i <tt>*OggWriter</tt> <tt>WriteRTP</tt> packet *rtp.Packet error</span></span><span class="entry code"><span class="entry-timestamp">03:20</span> <span class="entry-type">&gt;</span> <span class="entry-content">use f8 ff fe as the empty packet payload</span></span><span class="entry code"><span class="entry-timestamp">03:23</span> <span class="entry-type">&gt;</span> <span class="entry-content">can we use an initial value for the <tt>lastPacketTimestamp</tt> to make it work properly when the first packet of the results is not actually at t0.0? we might need to add silence at the beginning of the ogg</span></span><span class="entry code"><span class="entry-timestamp">03:24</span> <span class="entry-type">&gt;</span> <span class="entry-content">that seems a bit convoluted</span></span><span class="entry"><span class="entry-timestamp">03:25</span> <span class="entry-type">undo</span> </span><span class="entry code"><span class="entry-timestamp">03:26</span> <span class="entry-type">&gt;</span> <span class="entry-content">before writing the first packet, check the <tt>created_at</tt> against the time requested, and add silence if necessary</span></span><span class="entry code"><span class="entry-timestamp">03:27</span> <span class="entry-type">&gt;</span> <span class="entry-content">refactor that by creating a struct with methods</span></span><span class="entry code"><span class="entry-timestamp">03:28</span> <span class="entry-type">&gt;</span> <span class="entry-content">refactor <tt>packetInfoCmd</tt> by creating a new struct with methods, just call it Ogg</span></span><span class="entry code"><span class="entry-timestamp">03:29</span> <span class="entry-type">&gt;</span> <span class="entry-content">i think the ogg struct should be agnostic of the database, it should be called in a loop from the command</span></span><span class="entry code"><span class="entry-timestamp">03:30</span> <span class="entry-type">&gt;</span> <span class="entry-content">don&#39;t build up an array there, just stream from the rows into <tt>ogg.WriteOpusPacket</tt></span></span><span class="entry code"><span class="entry-timestamp">03:31</span> <span class="entry-type">&gt;</span> <span class="entry-content"><tt>ogg.go</tt> should not use pgx, it should not have a <tt>ProcessPackets</tt> function, it should have a <tt>WritePacket</tt> function, and the command code should call that repeatedly while iterating over rows</span></span><span class="entry code"><span class="entry-timestamp">03:32</span> <span class="entry-type">&gt;</span> <span class="entry-content">refactor the silence packet code</span></span><span class="entry code"><span class="entry-timestamp">03:41</span> <span class="entry-type">&gt;</span> <span class="entry-content">there&#39;s some time zone confusion, like INFO Added initial silence duration 3h0m7.367661s <tt>created_at</tt> &#34;2024-08-02 03:40:39.367661 +0000 UTC&#34; <tt>start_time</tt> &#34;2024-08-02 03:40:32 +0300 EEST&#34;</span></span><span class="entry code"><span class="entry-timestamp">03:47</span> <span class="entry-type">&gt;</span> <span class="entry-content">write a migration sql file that sets all timestamp columns to timestamptz and sets the value to the previous value reinterpreted as EEST</span></span><span class="entry code"><span class="entry-timestamp">03:56</span> <span class="entry-type">&gt;</span> <span class="entry-content">write a shell script that converts <tt>output.ogg</tt> to mp3</span></span><span class="entry code"><span class="entry-timestamp">04:04</span> <span class="entry-type">&gt;</span> <span class="entry-content">we need to track the packet sequence number ourselves and just start it from 1 or whatever and increment</span></span><span class="entry code"><span class="entry-timestamp">04:05</span> <span class="entry-type">&gt;</span> <span class="entry-content">also in the silent packets</span></span><span class="entry code"><span class="entry-timestamp">04:05</span> <span class="entry-type">&gt;</span> <span class="entry-content">refactor the packet creation code to unduplicate it</span></span><span class="entry code"><span class="entry-timestamp">04:09</span> <span class="entry-type">&gt;</span> <span class="entry-content">we might as well also just send timestamp as <tt>sequenceNumber</tt> * 960</span></span><span class="entry code"><span class="entry-timestamp">04:23</span> <span class="entry-type">&gt;</span> <span class="entry-content">make the ogg command now convert to ogg opus reencoding with ffmpeg to 64kbps and then sending it to the openai whisper sdk</span></span><span class="entry code"><span class="entry-timestamp">04:30</span> <span class="entry-type">&gt;</span> <span class="entry-content">convert to mp3 instead </span></span><span class="entry code"><span class="entry-timestamp">04:31</span> <span class="entry-type">&gt;</span> <span class="entry-content">instead of transcoding to ogg opus, do it with mp3 before whispering</span></span><span class="entry code"><span class="entry-timestamp">04:58</span> <span class="entry-type">&gt;</span> <span class="entry-content">refactor <tt>convertAndTranscribe</tt> so it doesn&#39;t transcribe, then make <tt>transcribeWithWhisper</tt> and <tt>transcribeWithDeepgram</tt></span></span><span class="entry"><span class="entry-timestamp">05:12</span> <span class="entry-type">+</span> <span class="entry-content"><tt>upload.go</tt></span></span><span class="entry"><span class="entry-timestamp">05:12</span> <span class="entry-type">+</span> <span class="entry-content"><tt>db_init.sql</tt></span></span><span class="entry code"><span class="entry-timestamp">05:12</span> <span class="entry-type">&gt;</span> <span class="entry-content">we need to adapt the old <tt>upload.go</tt> thing and the gemini transcription thingy and try using that in <tt>main.go</tt></span></span><span class="entry code"><span class="entry-timestamp">05:14</span> <span class="entry-type">&gt;</span> <span class="entry-content">there&#39;s no ievadb module in this project, checkout <tt>main.go</tt> and harmonize the database handling</span></span><span class="entry code"><span class="entry-timestamp">05:29</span> <span class="entry-type">&gt;</span> <span class="entry-content">we&#39;re gonna have to ffmpeg our ogg into mp3 to get a safe format for speechmatics</span></span><span class="entry code"><span class="entry-timestamp">05:32</span> <span class="entry-type">&gt;</span> <span class="entry-content">don&#39;t set mime type to opus</span></span><span class="entry"><span class="entry-timestamp">05:47</span> <span class="entry-type">+</span> <span class="entry-content"><tt>speechmatics/client.go</tt></span></span><span class="entry"><span class="entry-timestamp">05:47</span> <span class="entry-type">-</span> <span class="entry-content"><tt>upload.go</tt></span></span><span class="entry code"><span class="entry-timestamp">05:47</span> <span class="entry-type">&gt;</span> <span class="entry-content">see if you can make gemini/speechmatics two options for doing the transcription</span></span><span class="entry code"><span class="entry-timestamp">05:53</span> <span class="entry-type">&gt;</span> <span class="entry-content">see if you can make gemini and speechmatics into two options for doing the transcription</span></span><span class="entry code"><span class="entry-timestamp">06:09</span> <span class="entry-type">&gt;</span> <span class="entry-content">in <tt>ogg.go</tt> we actually can&#39;t get the timestamp from segment number unless we keep a uint32 segment number counter, because the uint16 is too small and is designed to wrap around to 0</span></span><span class="entry"><span class="entry-timestamp">06:13</span> <span class="entry-type">-</span> <span class="entry-content"><tt>ogg.go</tt> <tt>speechmatics/client.go</tt></span></span><span class="entry code"><span class="entry-timestamp">06:14</span> <span class="entry-type">&gt;</span> <span class="entry-content">identify some repetition and ugly code in <tt>main.go</tt> and improve that file</span></span><span class="entry code"><span class="entry-timestamp">06:48</span> <span class="entry-type">&gt;</span> <span class="entry-content">can you use dbx to make the query scanning more pleasant with structs?</span></span><span class="entry code"><span class="entry-timestamp">06:49</span> <span class="entry-type">&gt;</span> <span class="entry-content">can you use sqlc for the queries and stuff in <tt>main.go</tt>?</span></span><span class="entry code"><span class="entry-timestamp">06:52</span> <span class="entry-type">&gt;</span> <span class="entry-content">make an sqlc conf </span></span><span class="entry"><span class="entry-timestamp">06:54</span> <span class="entry-type">$</span> <span class="entry-content">go build <tt>main.go</tt> -o <tt>node.town</tt></span></span><span class="entry"><span class="entry-timestamp">06:54</span> <span class="entry-type">$</span> <span class="entry-content">make build</span></span><span class="entry code"><span class="entry-timestamp">06:56</span> <span class="entry-type">&gt;</span> <span class="entry-content">get rid of pgxpool, use normal sqlc database/sql sosmething something</span></span><span class="entry"><span class="entry-timestamp">06:58</span> <span class="entry-type">+</span> <span class="entry-content"><tt>queries.sql</tt></span></span><span class="entry code"><span class="entry-timestamp">06:58</span> <span class="entry-type">&gt;</span> <span class="entry-content">implement the <tt>GetLastJoinedChannel</tt> query</span></span><span class="entry code"><span class="entry-timestamp">07:02</span> <span class="entry-type">&gt;</span> <span class="entry-content">implement the <tt>InsertVoiceStateEvent</tt> query</span></span><span class="entry code"><span class="entry-timestamp">07:09</span> <span class="entry-type">&gt;</span> <span class="entry-content">the <tt>packetInfoCmd</tt> should also use sqlc queries</span></span><span class="entry code"><span class="entry-timestamp">07:12</span> <span class="entry-type">&gt;</span> <span class="entry-content">FATA Failed to execute embedded <tt>db_init.sql</tt> error &#34;pq: SSL is not enabled on the server&#34;</span></span><span class="entry code"><span class="entry-timestamp">07:15</span> <span class="entry-type">&gt;</span> <span class="entry-content">add a unique constraint in the ssrc mapping table</span></span><span class="entry code"><span class="entry-timestamp">07:16</span> <span class="entry-type">&gt;</span> <span class="entry-content">make a migration .sql in <tt>migrations/002_something.sql</tt></span></span><span class="entry code"><span class="entry-timestamp">07:16</span> <span class="entry-type">&gt;</span> <span class="entry-content">uh no i meant to add the unique constraint we just put on the ssrc map</span></span><span class="entry code"><span class="entry-timestamp">07:17</span> <span class="entry-type">&gt;</span> <span class="entry-content">replace the 002 something migration with one that just adds that unique constraint</span></span><span class="entry code"><span class="entry-timestamp">07:19</span> <span class="entry-type">&gt;</span> <span class="entry-content"><tt>main.go</tt> should have a single function for opening the database, now e.g. <tt>packetInfoCmd</tt> has its own -- generally clean up how stuff like that&#39;s setup in the main module</span></span><span class="entry code"><span class="entry-timestamp">07:25</span> <span class="entry-type">&gt;</span> <span class="entry-content">now make a kind of report query and print it in a tabular way with the jamie report command</span></span><span class="entry ask"><span class="entry-timestamp">13:03</span> <span class="entry-type">?</span> <span class="entry-content">i&#39;m thinking about, like, i&#39;m archiving a bunch of voice streams from discord as opus packets in a timeline, but actually a lot of those packets don&#39;t actually contain any speech or anything, it&#39;s just like the sound of breathing or typing or whatever and the primitive VAD gate says ohhh record record but actually i want some way to figure out which packets are actually worth paying attention to</span></span><span class="entry ask"><span class="entry-timestamp">13:29</span> <span class="entry-type">?</span> <span class="entry-content">i want a way to find stretches or segments with a tweakable gap tolerance, like i want to find ok here this stream&#39;s been producing packets for 3 minutes with just some pauses of a few seconds</span></span><span class="entry ask"><span class="entry-timestamp">13:30</span> <span class="entry-type">?</span> <span class="entry-content">make a command for finding speech segments</span></span><span class="entry ask"><span class="entry-timestamp">13:30</span> <span class="entry-type">?</span> <span class="entry-content">make a command for finding speech segments, i mean a cobra command</span></span><span class="entry"><span class="entry-timestamp">13:30</span> <span class="entry-type">+</span> <span class="entry-content"><tt>main.go</tt></span></span><span class="entry code"><span class="entry-timestamp">13:31</span> <span class="entry-type">&gt;</span> <span class="entry-content">ok let&#39;s implement that</span></span><span class="entry code"><span class="entry-timestamp">13:31</span> <span class="entry-type">&gt;</span> <span class="entry-content">add the query to the sql</span></span><span class="entry"><span class="entry-timestamp">13:43</span> <span class="entry-type">undo</span> </span><span class="entry ask"><span class="entry-timestamp">13:45</span> <span class="entry-type">?</span> <span class="entry-content">where in <tt>main.go</tt> do we still use non-sqlc querying?</span></span><span class="entry code"><span class="entry-timestamp">13:45</span> <span class="entry-type">&gt;</span> <span class="entry-content">the <tt>uploadFile</tt> function should use sqlc queries for sure</span></span><span class="entry"><span class="entry-timestamp">13:46</span> <span class="entry-type">$</span> <span class="entry-content">make</span></span><div class="date">Saturday, 3 August</div><span class="entry code"><span class="entry-timestamp">14:55</span> <span class="entry-type">&gt;</span> <span class="entry-content">can we make the cflags env stuff nicer? it&#39;s repeated in several targets now</span></span><span class="entry code"><span class="entry-timestamp">14:55</span> <span class="entry-type">&gt;</span> <span class="entry-content">is there any way to just export those globally in the makefile somehow</span></span><span class="entry"><span class="entry-timestamp">15:16</span> <span class="entry-type">+</span> <span class="entry-content"><tt>doc/speechmatics.md</tt></span></span><span class="entry"><span class="entry-timestamp">15:16</span> <span class="entry-type">+</span> <span class="entry-content"><tt>speechmatics/client.go</tt></span></span><span class="entry"><span class="entry-timestamp">15:16</span> <span class="entry-type">+</span> <span class="entry-content"><tt>speechmatics/transcript.go</tt></span></span><span class="entry code"><span class="entry-timestamp">15:17</span> <span class="entry-type">&gt;</span> <span class="entry-content">make the speechmatics client capable of doing websocket real time transcription in addition to the current batch job functionality</span></span><span class="entry code"><span class="entry-timestamp">15:19</span> <span class="entry-type">&gt;</span> <span class="entry-content">can we merge the <tt>RTConfig</tt> and <tt>TranscriptionConfig</tt> in some nice way?</span></span><span class="entry"><span class="entry-timestamp">15:26</span> <span class="entry-type">+</span> <span class="entry-content"><tt>snd/ogg.go</tt></span></span><span class="entry ask"><span class="entry-timestamp">15:27</span> <span class="entry-type">?</span> <span class="entry-content">in <tt>snd/ogg.go</tt> is there support for &#34;streaming&#34; ogg containers? like i want to send an ogg stream to a real time API for example</span></span><span class="entry code"><span class="entry-timestamp">15:28</span> <span class="entry-type">&gt;</span> <span class="entry-content">let&#39;s implement that</span></span><span class="entry"><span class="entry-timestamp">15:33</span> <span class="entry-type">$</span> <span class="entry-content">make</span></span><span class="entry ask"><span class="entry-timestamp">16:32</span> <span class="entry-type">?</span> <span class="entry-content">where is it that we&#39;re using the postgres listen/notify</span></span><span class="entry ask"><span class="entry-timestamp">16:34</span> <span class="entry-type">?</span> <span class="entry-content">i want to extract that functionality to <tt>snd/stream.go</tt> as a function that returns a channel</span></span><span class="entry code"><span class="entry-timestamp">16:35</span> <span class="entry-type">&gt;</span> <span class="entry-content">let&#39;s implement that</span></span><span class="entry code"><span class="entry-timestamp">16:39</span> <span class="entry-type">&gt;</span> <span class="entry-content">now i want to separate those streaming packets by stream... make a new function in <tt>snd/stream.go</tt> called demux or something which returns a chan of chans</span></span><span class="entry code"><span class="entry-timestamp">16:42</span> <span class="entry-type">&gt;</span> <span class="entry-content">make a new package <tt>tts/tts.go</tt> with a cobra command that prints streaming info from the demuxed opus packet stream, add to <tt>main.go</tt></span></span><span class="entry ask"><span class="entry-timestamp">16:52</span> <span class="entry-type">?</span> <span class="entry-content">in <tt>OpusPacketNotification</tt> the opus data is a byte array, the pg col is a bytea, but it seems to expect base64 for decoding </span></span><span class="entry ask"><span class="entry-timestamp">16:53</span> <span class="entry-type">?</span> <span class="entry-content">hmm uhh i think the issue was rather that postgres <tt>row_to_json</tt> does not send base64?</span></span><span class="entry code"><span class="entry-timestamp">16:55</span> <span class="entry-type">&gt;</span> <span class="entry-content">i think we should use string instead of []byte in the struct</span></span><span class="entry code voice"><span class="entry-timestamp">17:01</span> <span class="entry-type">&gt;</span> <span class="entry-content">could you make the opus streaming thing like also keep track of the ssrc to userid mapping somehow in like a cache or something?</span></span><span class="entry code voice"><span class="entry-timestamp">17:05</span> <span class="entry-type">&gt;</span> <span class="entry-content">the userids are not actually included in the postgres notification payload we have to look that up with a query and populate the cache from that it&#39;s a bit excessive to do that every time we get a packet so i think we should instead like when we get a packet then if the cache doesn&#39;t have that ssrc key then you look it up in the database and if there is an entry in the database you set it</span></span><span class="entry code voice"><span class="entry-timestamp">17:06</span> <span class="entry-type">&gt;</span> <span class="entry-content">in the place where you&#39;re getting from the cache now the <tt>cache.get</tt> method actually returns the userid or empty if there is no entry in the cache and then it returns also an error value and the error value is only non-nil if there was an actual error in looking it up in the database</span></span><span class="entry code voice"><span class="entry-timestamp">17:06</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay but there&#39;s another place where we get from the cache so we should probably extract a function for that</span></span><span class="entry"><span class="entry-timestamp">17:08</span> <span class="entry-type">+</span> <span class="entry-content"><tt>db/queries.sql</tt></span></span><span class="entry"><span class="entry-timestamp">17:08</span> <span class="entry-type">+</span> <span class="entry-content"><tt>sqlc.yaml</tt></span></span><span class="entry code"><span class="entry-timestamp">17:08</span> <span class="entry-type">&gt;</span> <span class="entry-content">use an sqlc query instead of selecting in <tt>SSRCUserIDCache</tt></span></span><span class="entry"><span class="entry-timestamp">17:09</span> <span class="entry-type">+</span> <span class="entry-content"><tt>db/db_init.sql</tt></span></span><span class="entry code"><span class="entry-timestamp">17:09</span> <span class="entry-type">&gt;</span> <span class="entry-content"><tt>GetUserIDBySSRC</tt> needs to look up in the <tt>ssrc_mappings</tt> table or whatever</span></span><span class="entry"><span class="entry-timestamp">17:10</span> <span class="entry-type">$</span> <span class="entry-content">make</span></span><span class="entry code voice"><span class="entry-timestamp">17:13</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay that&#39;s cool that&#39;s working so i wonder now i would like to have a way to transcribe in real time the Speechmatics API and i think that could be like a flag to the listen packets command no not the listen packets command i mean the stream command um like dash dash transcribe or something and it would like for each new channel of packets that it sees it will create a new Speechmatics um real time session or whatever and then just like print results as they come in you know log the results</span></span><span class="entry code voice"><span class="entry-timestamp">17:18</span> <span class="entry-type">&gt;</span> <span class="entry-content">uh when we connect to the Speechmatics web socket uh we need to like send this start recognition message but then we need some way to uh wait for uh what&#39;s it called the recognition started event message um so i think we can return a channel from connect web socket that&#39;s like the ready channel and then um when we um or never mind not do a channel just wait for it in the connect web socket function so we don&#39;t have to worry about it</span></span><span class="entry ask"><span class="entry-timestamp">17:20</span> <span class="entry-type">?</span> <span class="entry-content">are we now sending opus packets to the speechmatics socket, or ogg pages?</span></span><span class="entry ask"><span class="entry-timestamp">17:20</span> <span class="entry-type">?</span> <span class="entry-content">we&#39;ll need to use our streaming ogg writer for this</span></span><span class="entry code"><span class="entry-timestamp">17:22</span> <span class="entry-type">&gt;</span> <span class="entry-content">ok do that but don&#39;t change anything with the audio format, just type file is enough</span></span><span class="entry code voice"><span class="entry-timestamp">17:34</span> <span class="entry-type">&gt;</span> <span class="entry-content">so speechmatics is saying that the audio data is invalid i think but i&#39;m not sure why um it would be helpful if you could like um also save what you write like save the ogg streams to files call them like tmp slash whatever the ssrc dot ogg and just yeah just save that um and i can take a look at them</span></span><span class="entry code voice"><span class="entry-timestamp">17:37</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay now we&#39;re using the variable packet uh outside the loop where that variable is available and handled stream with transcription so i think what we need to do actually is like inside the for loop that reads the packets from the stream just like um um you know the first time we get a packet that&#39;s when we can like uh start the ogg start the ogg writer or whatever you know what i mean</span></span><span class="entry code voice"><span class="entry-timestamp">17:44</span> <span class="entry-type">&gt;</span> <span class="entry-content">um in the speechmatics package the connect websocket method can you make sure that it prints the json messages that it sends</span></span><span class="entry code voice"><span class="entry-timestamp">17:52</span> <span class="entry-type">&gt;</span> <span class="entry-content">when we read the transcript response it&#39;s from speechmatics um can you instead of using the read json thing from the websocket just like read the message print the uh raw json and then uh deserialize it</span></span><span class="entry code voice"><span class="entry-timestamp">17:56</span> <span class="entry-type">&gt;</span> <span class="entry-content">something is really weird about how the buffer and the writer are handled in the ogg package i mean in the snd package in the ogg file um it&#39;s doing something weird like i think it&#39;s it has like its own buffer and when you flush it writes that buffer but it&#39;s also immediately writing to the writer um i don&#39;t know if we even need to have a buffer in this thing you know we can just write to the writer and they can do their own buffering or whatever</span></span><span class="entry code voice"><span class="entry-timestamp">18:13</span> <span class="entry-type">&gt;</span> <span class="entry-content">there&#39;s an issue where um the ogg file that we create when we do the streaming thing um actually has like ascii hex string stuff in it like in the binary so i suspect that postgres is sending us the byte array as a hex string or you know somehow it gets yeah it gets read as a hexa string um could you like in the stream opus packets function when you like after you do the unmarshaling can you check if the the um like opus packet that you receive if that starts with like backslash x or you know or just print the first like four bytes of the opus packet when you get them</span></span><span class="entry code voice"><span class="entry-timestamp">18:14</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay so in fact they do all start with backslash x so we can just assume that that&#39;s how we get to run the database and we don&#39;t need to do the conditional just you know try to decode that you know and maybe like panic if it doesn&#39;t start with backslash x or whatever</span></span><span class="entry code voice"><span class="entry-timestamp">18:14</span> <span class="entry-type">&gt;</span> <span class="entry-content">also i&#39;m currently seeing in the log so much uh you know just the rtp info messages and that is really noisy so could you maybe put that in the debugger logger instead</span></span><span class="entry code voice"><span class="entry-timestamp">18:15</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay now also put use debug log level for like decoded opus packet data sent audio yeah</span></span><span class="entry code voice"><span class="entry-timestamp">18:20</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay now use the debug logger also for received raw json</span></span><span class="entry code voice"><span class="entry-timestamp">18:26</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay so this is a bit um of a major thing but so from discord we get opus packets when we speak we don&#39;t get any opus packets when there&#39;s silence but in the stream to speechmatics you know in that og container that we&#39;re sending we are actually inserting silent packets when we detect a need to do that but that we only do that once we get the next opus packet after the silence so i think what we need to do is um uh have some kind of a timer or something to make sure that we send silent packets to speechmatics even just regularly you know if there are no opus packets coming in</span></span><span class="entry code voice"><span class="entry-timestamp">18:27</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay i think we shouldn&#39;t have the silent packet code there like we already have support for this in the smd slash og um we just need to have a way to you know just like poke the og writer every let&#39;s say 100 milliseconds uh and then you know i should just send as many silent packets as it needs something like that</span></span><span class="entry code voice"><span class="entry-timestamp">18:28</span> <span class="entry-type">&gt;</span> <span class="entry-content">then we have some duplicate code now in the <tt>og.go</tt> file related to the silences and stuff</span></span><span class="entry code voice"><span class="entry-timestamp">18:32</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay now let&#39;s do something cool here uh in the tts package make a new file called <tt>ui.go</tt> and it&#39;s going to use bubble tea to show transcriptions of streams in real time so now we might need to restructure the <tt>tts.go</tt> file to give us some way of like hooking into that i wonder how to do that um maybe well i&#39;m not sure but maybe you can come up with a nice way to do that using channels or something to transmit data to the bubble tea thingy</span></span><span class="entry code voice"><span class="entry-timestamp">18:38</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay when we&#39;re in the ui mode we can&#39;t have a logger that logs to uh stdio we need to like make it log to a file or whatever or just nothing</span></span><span class="entry code voice"><span class="entry-timestamp">18:39</span> <span class="entry-type">&gt;</span> <span class="entry-content">wait that&#39;s a bit verbose can&#39;t we just uh like where do these log things come from okay i guess we&#39;re just using the log packet directly as a convenience maybe there is a way to just like set parameters on the default logger instead</span></span><span class="entry"><span class="entry-timestamp">18:40</span> <span class="entry-type">$</span> <span class="entry-content">make build</span></span><span class="entry code voice"><span class="entry-timestamp">18:44</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay i just think that the listen for transcripts function is not being actually called anywhere</span></span><span class="entry code voice"><span class="entry-timestamp">18:47</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay now we need to distinguish between partial transcripts and final transcripts and we do that by checking the message field of the json we get from speechmatics if it&#39;s like add transcript versus add partial transcript i think they&#39;re called something like that and so then that needs to um you know that information we need that information to go down to the ui as well because when we get a non-partial transcript we need to like make a new line you know first like update the current line and then make a new line and when we get the partial transcripts we are always just going to update the current line with like because the partial transcripts are always have the full contents of the partial thing so yeah you know</span></span><span class="entry"><span class="entry-timestamp">18:47</span> <span class="entry-type">$</span> <span class="entry-content">make build</span></span><span class="entry code voice"><span class="entry-timestamp">18:54</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay so um in the handle stream with transcription and ui when we loop over the results field of the transcript we&#39;re actually looping over words in the transcript so i think we want to actually um um like maybe we should send uh to the ui channel we should be sending like slices of transcript messages or no the transcript message instead of having a text field it should have a words field which will be populated from the results array and that can also like include the confidence and the timing we don&#39;t need to show the timing in the ui but we could use the confidence um like we can have a bit of a color coding based on the confidence per word</span></span><span class="entry"><span class="entry-timestamp">18:55</span> <span class="entry-type">$</span> <span class="entry-content">make build</span></span><span class="entry code voice"><span class="entry-timestamp">18:58</span> <span class="entry-type">&gt;</span> <span class="entry-content">uh um in the ui when we get the transcript messages uh when we get the final transcript then we should like uh you know change the current line to be made of the words that are in the final transcript and then start a new current line because now we&#39;re getting duplicate like we&#39;re getting two lines for each actual transcript</span></span><span class="entry code voice"><span class="entry-timestamp">19:03</span> <span class="entry-type">&gt;</span> <span class="entry-content">oh here&#39;s an interesting thing uh we can get sometimes from speechmatics we get an add transcript not partial um but it has a field called attaches to set to the string previous and um in that case that needs to also like trickle down to the ui so that it can update the previous transcript line rather than um rather than make a new one</span></span><span class="entry code voice"><span class="entry-timestamp">19:07</span> <span class="entry-type">&gt;</span> <span class="entry-content">hmm i think in the ui code where you&#39;re checking the attaches to field um that you know update previous line thing should probably be in the else branch that handles final transcripts and like uh it&#39;s just that you know if the attaches to is previous then you don&#39;t change the current line you update the previous line or i don&#39;t know if that&#39;s even true something is weird like i still see those uh final edited lines come on a separate line and i don&#39;t know why</span></span><span class="entry code voice"><span class="entry-timestamp">19:08</span> <span class="entry-type">&gt;</span> <span class="entry-content">can you also make it so that like each line in the ui um begins with like a terse representation of some kind of metadata so that because i&#39;m like i&#39;m not sure if it even uh does this you know previous attachment thing so like i want there to be some way to know that</span></span><span class="entry code voice"><span class="entry-timestamp">19:10</span> <span class="entry-type">&gt;</span> <span class="entry-content">i don&#39;t know something is weird like i don&#39;t think we should have that attaches to field in like the words or yeah okay i guess that what something&#39;s like weird so like i don&#39;t think the words thing in the ui each like what yeah like there shouldn&#39;t be uh attaches to field in the transcript word structure that&#39;s weird you know i don&#39;t know how that ended up there</span></span><span class="entry"><span class="entry-timestamp">19:11</span> <span class="entry-type">$</span> <span class="entry-content">make build</span></span><span class="entry code voice"><span class="entry-timestamp">19:16</span> <span class="entry-type">&gt;</span> <span class="entry-content">the ui model messages struct should not have an <tt>attachesTo</tt> field, instead when we do the attach previous handling just put a little tag in the previous line that says we attached, it&#39;s just for debugging</span></span><span class="entry code"><span class="entry-timestamp">19:18</span> <span class="entry-type">&gt;</span> <span class="entry-content">the ui model messages struct should not have an <tt>attachesTo</tt> field, instead when we do the attach previous handling just put a little tag in the previous line that says we attached, it&#39;s just for debugging</span></span><span class="entry code voice"><span class="entry-timestamp">19:20</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay it&#39;s still kind of confusing let&#39;s try this okay in the ui make two panels so on the left you show the messages just like now but on the right you show um like a log like a simple terse little log of um you know transcript information</span></span><span class="entry code voice"><span class="entry-timestamp">19:30</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay instead of the two panel ui um make it so you can switch between the transcript and the log use because um the layout is a bit weird and i don&#39;t want that complexity</span></span><span class="entry code voice"><span class="entry-timestamp">19:31</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay so now uh include like make the log messages better like show the actual words and also show whether it&#39;s supposed to attach the previous or not</span></span><span class="entry code voice"><span class="entry-timestamp">19:37</span> <span class="entry-type">&gt;</span> <span class="entry-content">oh i see the problem uh the <tt>attachesTo</tt> field that we get from Speechmatics is actually in the results struct so next to alternatives and so on it&#39;s not in the level above as we have now</span></span><span class="entry"><span class="entry-timestamp">19:38</span> <span class="entry-type">$</span> <span class="entry-content">make build</span></span><span class="entry code voice"><span class="entry-timestamp">19:39</span> <span class="entry-type">&gt;</span> <span class="entry-content">no we actually want to have the <tt>attachesTo</tt> information sent to the ui in the transcript message um um which is not implemented correctly or something</span></span><span class="entry code voice"><span class="entry-timestamp">19:45</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay wait there&#39;s been a mix-up so um the rt transcript response struct should have the <tt>attachesTo</tt> field inside of the results struct so there is one <tt>attachesTo</tt> for each result okay so change that in <tt>client.go</tt> and also update the usages in other places</span></span><span class="entry code voice"><span class="entry-timestamp">19:47</span> <span class="entry-type">&gt;</span> <span class="entry-content">yeah okay um so now in the ui back in the ui file um when we get a final transcript if it has <tt>attachesTo</tt> set to previous then we need to update the previous line uh instead of putting this in a new line so</span></span><span class="entry code voice"><span class="entry-timestamp">19:53</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay um the speechmatics api also sends um in the same struct where you have <tt>attachesTo</tt> there is also a field called is eos is underscore eos i guess that means end of sentence or you know and also a field called type which can have which can have um which can be either word or punctuation so can you add that to our structs and then pass that down to the ui or maybe that will have an automatically and then uh when we put the spaces in between the words like only put a hmm like you should only put space when um when we&#39;re uh you should put a space before each word unless they are the first word in the message in the line something like that</span></span><span class="entry"><span class="entry-timestamp">19:54</span> <span class="entry-type">+</span> <span class="entry-content"><tt>speechmatics/transcript.go</tt></span></span><span class="entry code voice"><span class="entry-timestamp">19:55</span> <span class="entry-type">&gt;</span> <span class="entry-content">um this is a bit weird uh in the parse transcript function like we don&#39;t want to duplicate that whole struct definition for the results and things there uh we should use the one that we already defined in like the client no well in the client we should have like a named struct there which is a result or whatever and that should have the end of sentence field so you know i didn&#39;t have the transcript the file added to the chat earlier so i think that&#39;s what caused some confusion</span></span><span class="entry code voice"><span class="entry-timestamp">20:00</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay um in the ui we should show each sentence like somehow we should have a list of sentences to show um and you know we make a new like we draw a new sentence when we have the end of sentence marker</span></span><span class="entry code voice"><span class="entry-timestamp">20:03</span> <span class="entry-type">&gt;</span> <span class="entry-content">now we&#39;re getting a slice range panic uh on the line inside the check for end of sentence branch um uh wait which one which line was it it was yeah it&#39;s the one where you are taking the i plus one slice from the current sentence um that doesn&#39;t seem to work</span></span><span class="entry code voice"><span class="entry-timestamp">20:06</span> <span class="entry-type">&gt;</span> <span class="entry-content">this um doesn&#39;t work very well i think we can we should simplify this and just uh just don&#39;t have the don&#39;t have a sentences field in the ui model the ui model should just have um like or no maybe maybe we can have that no it&#39;s weird uh i think the weird thing is that um um we&#39;ll often get the end of sentence tag when there is the final transcript with the previous attachment and we&#39;re just not handling that at all now like i don&#39;t know i&#39;m confused about how this all should work it&#39;s all a bit strange to me</span></span><span class="entry"><span class="entry-timestamp">20:07</span> <span class="entry-type">undo</span> </span><span class="entry code voice"><span class="entry-timestamp">20:09</span> <span class="entry-type">&gt;</span> <span class="entry-content">i think we should change so that the ui model doesn&#39;t have a sentences list the ui model should have a list of um like a list of final transcripts and an ongoing current transcript and then when we render the view then you know you put a new line on the end of sentence words and then you don&#39;t need to check for that stuff in the update function</span></span><span class="entry code voice"><span class="entry-timestamp">20:35</span> <span class="entry-type">&gt;</span> <span class="entry-content">hey um in the transcript view function when we write the dash string um we should only do that if like we should first do the format words call and then we should see or wait yeah maybe rather what we should do is uh before writing the dash we just check like if the current transcript has a first word that is not punctuation i guess</span></span><span class="entry code"><span class="entry-timestamp">20:39</span> <span class="entry-type">&gt;</span> <span class="entry-content">/chat-mode</span></span><span class="entry ask"><span class="entry-timestamp">20:39</span> <span class="entry-type">?</span> <span class="entry-content">when the ui quits, what happens?</span></span><span class="entry ask voice"><span class="entry-timestamp">20:53</span> <span class="entry-type">?</span> <span class="entry-content">okay uh in the ui could you make it so that uh in the format words thing and like the way we use format words um it should take a parameter for the background color and we should like use some a background color to indicate when uh it&#39;s the current you know non-final transcript that we&#39;re showing</span></span><span class="entry ask voice"><span class="entry-timestamp">21:01</span> <span class="entry-type">?</span> <span class="entry-content">change the coloring of the words so it&#39;s not so green you know when the confidence is green it should be rendered as just white and um and then instead of yellow and red it should be just like um all right okay keep the yellow and red but make the green white</span></span><span class="entry"><span class="entry-timestamp">21:06</span> <span class="entry-type">+</span> <span class="entry-content"><tt>tts/tts.go</tt></span></span><span class="entry ask voice"><span class="entry-timestamp">21:07</span> <span class="entry-type">?</span> <span class="entry-content">hey uh in the handle transcript and errors with ui function um you&#39;re looping over the results but i think we need to do this in a different way we need to like yeah we need to loop over the results but then like send separate like transcript messages for each such result because that has to do with the attaches to thing like because now i see you&#39;re doing like taking the zero index of the results but that&#39;s like losing information so just refactor that or like change the structure of that thing when you receive the transcripts and um make it so that make it so that more stuff is in the loop that loops over the results</span></span><span class="entry"><span class="entry-timestamp">21:08</span> <span class="entry-type">undo</span> </span><span class="entry ask voice"><span class="entry-timestamp">21:11</span> <span class="entry-type">?</span> <span class="entry-content">um okay in the handle transcript and errors with ui function we&#39;re taking the zero index of the results array and the transcript to find the attaches to but the attaches to is actually per word so i think actually the transcript word struct should have the attaches to and then we need to handle that differently in the ui as well</span></span><span class="entry ask voice"><span class="entry-timestamp">21:13</span> <span class="entry-type">?</span> <span class="entry-content">so now in the ui uh in the transcript message handler we&#39;re checking attaches to on the wrong struct now i think maybe we don&#39;t need to even check the attaches to thing there we just yeah we just add a new final transcript and then when we render later when we render the content transcript view um we need to like like in the format words function i guess that&#39;s what we need to check you know if this attaches to the previews then we don&#39;t um but the space something like that</span></span><span class="entry ask voice"><span class="entry-timestamp">21:22</span> <span class="entry-type">?</span> <span class="entry-content">we&#39;re having a lot of problems with the spacing and stuff i came up with something i think might help so in transcript view we&#39;re calling the function format words and um there are some issues when well there&#39;s some issues and i think one way to make it more robust and easy to understand would be to make like a stateful thing so a struct that&#39;s like a word builder or something which would have a string builder and it would accept the you know word arrays and it would call i mean yeah so the format words thing should be a method of that stateful thing and that this will let us um it&#39;ll be easier to keep track of when to put spaces and stuff like that</span></span><span class="entry ask voice"><span class="entry-timestamp">21:23</span> <span class="entry-type">?</span> <span class="entry-content">oh but the crucial thing is that the word builder should be something that you um you don&#39;t create a new word builder in the format words function instead you create one you create one in the transcript view function where we now create the string builder like that&#39;s the whole point</span></span><span class="entry ask voice"><span class="entry-timestamp">21:24</span> <span class="entry-type">?</span> <span class="entry-content">yeah that&#39;s good but then format words should be a method on the word builder called append words</span></span><span class="entry ask voice"><span class="entry-timestamp">21:26</span> <span class="entry-type">?</span> <span class="entry-content">okay now let&#39;s make it so that the um instead of a gray background on the on the temporary words use a gray foreground because anyway we don&#39;t have good confidence results for the partial transcripts</span></span><span class="entry ask voice"><span class="entry-timestamp">21:35</span> <span class="entry-type">?</span> <span class="entry-content">hey uh in the hand transcription errors with UI you&#39;re taking the zero index alternative for the content and confidence I think actually we should we should include we should have an array in the transcript word this is alternatives and we can keep the current content and confidence fields like they are but also include the alternatives field so that in the UI when we render a word um we can show them with you know uh separated by pipes and um in square brackets or something like that</span></span><span class="entry ask voice"><span class="entry-timestamp">21:37</span> <span class="entry-type">?</span> <span class="entry-content">yeah okay and now just um just um the confidence color should be per alternative in the UI so like the way that a color is sent to the append words function is redundant because we can deduce that from the is partial parameter and right the right word method should accept that is partial parameter instead of the style parameter and then it should just if it&#39;s the partial then use gray otherwise render the confidence color per alternative</span></span><span class="entry"><span class="entry-timestamp">21:40</span> <span class="entry-type">+</span> <span class="entry-content"><tt>db/db_init.sql</tt></span></span><span class="entry"><span class="entry-timestamp">21:40</span> <span class="entry-type">+</span> <span class="entry-content"><tt>db/queries.sql</tt></span></span><span class="entry ask voice"><span class="entry-timestamp">21:44</span> <span class="entry-type">?</span> <span class="entry-content">hey um so I&#39;m thinking about quite a major change so let&#39;s think this through at a slightly higher level first so the TTS package right now does like a speech medics session for transcribing and the results that it gets it kind of translates into some commands for the UI but I want to change this so that instead it um it saves the transcription results to the database in a nice schema so the schema would have like a table for um transcription segments or something and um so um okay well it&#39;s interesting to think about how to deal with alternative words um whether there will be some kind of identifier for each well so that is one thing to think about like what are the what are the identities what are the for which things will we have IDs like I think that we should have IDs for um I don&#39;t know maybe we should just have like I don&#39;t know let&#39;s think about it a little bit see what they&#39;ll see what we can now what are our options</span></span><span class="entry ask voice"><span class="entry-timestamp">21:50</span> <span class="entry-type">?</span> <span class="entry-content">yeah okay um I think we can simplify the schema a little bit by having um so the start time and end time of the transcription session those are going to be time stamps with time zones but um the segments will have instead like um offset and duration maybe wait the the segments shouldn&#39;t even have time information because that&#39;s in the words we just use the words for that in the in each word you have um like offset and duration so and maybe so I don&#39;t know maybe we can even have the is final in the words table or hmm now I&#39;m just thinking about like keeping it simple and less error prone</span></span><span class="entry ask voice"><span class="entry-timestamp">21:56</span> <span class="entry-type">?</span> <span class="entry-content">okay actually I think we should have a separate table for the partial words if that makes sense or no maybe it&#39;s it was better the way we had it which was like um have another layer so that the words don&#39;t just belong to the session but they belong to transcription segments and the segments are either final or not final so then when we are inserting in the database we can just like when we get the partial results we run a query that inserts into the you know the last segment or creates a new segment if the if there is a if the last segment is final something like that and then you know that seems right that seems reasonable and I guess um the alternative words thing is a bit weird that we have content and confidence also in the transcription words table I think maybe rather we should you know embrace that there are different alternatives so there&#39;s no content and confidence in the transcription words which is the um word alternatives table</span></span><span class="entry ask voice"><span class="entry-timestamp">21:57</span> <span class="entry-type">?</span> <span class="entry-content">yeah I think that seems basically good and now let&#39;s think about how to implement this I wonder if we can start by like not changing the UI code very much but just inserting to the database along with also you know doing the UI the way we do it now and like then in a later step we&#39;ll change the UI so that it is actually just streaming from the database</span></span><span class="entry ask voice"><span class="entry-timestamp">22:00</span> <span class="entry-type">?</span> <span class="entry-content">yeah all right so first of all let&#39;s we don&#39;t need to send like code blocks now that we&#39;re discussing but one thing I see there is that you&#39;re referring to a packet in the loop where we process transcripts but I&#39;m not sure that makes sense like we should probably start the transcription session when we get the first packet you know like when we actually connect to the API but okay I think this should be enough for starting with the implementation maybe one thing to keep in mind is also when where we&#39;re doing like back and forth to the database for checking if we need a new segment and I wonder if that stuff can be actually done as a query like if we can move some of that to SQL</span></span><span class="entry code voice"><span class="entry-timestamp">22:01</span> <span class="entry-type">&gt;</span> <span class="entry-content">all right let&#39;s try implementing this and add some logging as you go because I&#39;m sure there will be some issues and it&#39;s good to be able to debug that</span></span><span class="entry code voice"><span class="entry-timestamp">22:03</span> <span class="entry-type">&gt;</span> <span class="entry-content">hey could you move the upsert transcription segment function creation to the init like to the schema file and then you know in the queries file you would just actually call that function</span></span><span class="entry code voice"><span class="entry-timestamp">22:05</span> <span class="entry-type">&gt;</span> <span class="entry-content">well I think offset is like a reserved word or something so we&#39;re using that as the column name but maybe call it like maybe call it something else or something</span></span><span class="entry code"><span class="entry-timestamp">22:05</span> <span class="entry-type">&gt;</span> <span class="entry-content">well I think offset is like a reserved word or something so we&#39;re using that as the column name but maybe call it like maybe call it something else or something</span></span><span class="entry code voice"><span class="entry-timestamp">22:08</span> <span class="entry-type">&gt;</span> <span class="entry-content">oh we forgot to define the schema in the SQL for transcription segments transcription words and word alternatives</span></span><span class="entry code voice"><span class="entry-timestamp">22:08</span> <span class="entry-type">&gt;</span> <span class="entry-content">I think there is a duration type or something in Postgres isn&#39;t there</span></span><span class="entry code voice"><span class="entry-timestamp">22:12</span> <span class="entry-type">&gt;</span> <span class="entry-content">we have serial columns for the IDs now and word alternatives and transcription words so that limits us to four billion rows I think that is a bit not so good so we should use big serial for those for transcription sessions we can still use just serial or just use big serial there as well</span></span><span class="entry code voice"><span class="entry-timestamp">22:16</span> <span class="entry-type">&gt;</span> <span class="entry-content">I think that transcription segments tables shouldn&#39;t have starter and offsets we&#39;ll just have that in the words</span></span><span class="entry code voice"><span class="entry-timestamp">22:21</span> <span class="entry-type">&gt;</span> <span class="entry-content">can you make can you make it so that the UI doesn&#39;t actually show or render like I still want all the UI stuff to be like kind of running but I don&#39;t want to show it because I&#39;m getting some errors on the standard output that I need to see</span></span><span class="entry code voice"><span class="entry-timestamp">22:23</span> <span class="entry-type">&gt;</span> <span class="entry-content">can you by the way make it so that the program loads its own .env file you&#39;ll need it wait sorry first I forgot to add the <tt>main.go</tt> file so I&#39;ll have to do that first so you can actually do this and maybe we use Viper for this</span></span><span class="entry code voice"><span class="entry-timestamp">22:23</span> <span class="entry-type">&gt;</span> <span class="entry-content">yeah can you find other places where you use the environment variables</span></span><span class="entry code voice"><span class="entry-timestamp">22:24</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay we still need to update more stuff in the main file for the Gemini and Speechmatics API keys as well as in <tt>bot.go</tt> we&#39;re doing a get env and in <tt>postgres.go</tt> we&#39;re doing a get env</span></span><span class="entry"><span class="entry-timestamp">22:25</span> <span class="entry-type">+</span> <span class="entry-content"><tt>speechmatics/cli.go</tt></span></span><span class="entry code voice"><span class="entry-timestamp">22:25</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay now also in the Speechmatics <tt>CLI.go</tt> and in <tt>tts.go</tt></span></span><span class="entry code voice"><span class="entry-timestamp">22:49</span> <span class="entry-type">&gt;</span> <span class="entry-content">we need to change something with how we do the wait for notification thing in the stream file in the <tt>stream.go</tt> in the snd folder so there is no wait for notification method on the pool and in fact pgx pool doesn&#39;t support waiting for notifications so instead we should do like acquire a database connection and and then run the listen like do a exec of the listen command and and then wait for notification on that connection</span></span><span class="entry code voice"><span class="entry-timestamp">22:52</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay now in the <tt>tts.go</tt> make it so that it actually shows the Bubble TTY instead of just updating the model</span></span><span class="entry code voice"><span class="entry-timestamp">22:58</span> <span class="entry-type">&gt;</span> <span class="entry-content">I don&#39;t know something is weird with how the messages are handled in the UI file now like there&#39;s a listen for transcripts function that&#39;s not call anywhere and yeah I don&#39;t know how to deal with this</span></span><span class="entry code voice"><span class="entry-timestamp">23:01</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay but how do those messages actually get sent to the UI thing like I&#39;m not sure this makes sense like what&#39;s the normal way to just send messages into a thing and bubble tea blah</span></span><span class="entry code voice"><span class="entry-timestamp">23:06</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay look what we actually need to do is in the init for the model we need to return a command that&#39;s like wait for transcript and that needs to be a function that returns the T command which is a function that just reads from the channel okay something like that is what we need to do and then in the update function when we get the transcript message or whatever we need to you know return a new wait for transcript command</span></span><span class="entry ask voice"><span class="entry-timestamp">23:11</span> <span class="entry-type">?</span> <span class="entry-content">hey so now I want to do pretty significant change which is the UI currently gets its update messages in like a direct way and this is separate from the thing where we save transcript results to the database now what I want to do is make the UI operate based on the database that means the UI should also use a database connection that listens for a notification and we need like that notification should be mmm I guess the trigger that we define in the schema file so let&#39;s think about how to do that we&#39;re not going to implement it right away but we need to think about how to do it so mmm as you can see we are also listening in the database for the packets so we need to do something similar for this</span></span><span class="entry ask voice"><span class="entry-timestamp">23:13</span> <span class="entry-type">?</span> <span class="entry-content">yeah I think they are being saved um one thing we need to think about is how do we handle updates of the transcripts because well final transcript segments will not be changed but the non-final ones can change and so um we need something that triggers also when Hero is updated and then like we don&#39;t need to get all the final transcripts we just need to get the non-final transcripts because those are the ones that can actually be updated</span></span><span class="entry"><span class="entry-timestamp">23:14</span> <span class="entry-type">+</span> <span class="entry-content"><tt>snd/stream.go</tt></span></span><span class="entry code voice"><span class="entry-timestamp">23:15</span> <span class="entry-type">&gt;</span> <span class="entry-content">yeah okay let&#39;s try to implement that</span></span><span class="entry code voice"><span class="entry-timestamp">23:22</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay we also need to actually create the trigger for notifying about new transcript thingies you know because we&#39;re I think we are listening for that but and we&#39;re listening for transcription change but we are not actually triggering that anywhere</span></span><span class="entry code voice"><span class="entry-timestamp">23:24</span> <span class="entry-type">&gt;</span> <span class="entry-content">sorry I think I lost the code that you put in DB in it to make the trigger can you just insert that code again please</span></span><span class="entry code voice"><span class="entry-timestamp">23:25</span> <span class="entry-type">&gt;</span> <span class="entry-content">sorry can you do that again I&#39;m not sure what is going on but you need to do that again</span></span><span class="entry code voice"><span class="entry-timestamp">23:26</span> <span class="entry-type">&gt;</span> <span class="entry-content">no sorry can you insert the trigger definition in the DB in it file please</span></span><span class="entry code voice"><span class="entry-timestamp">23:27</span> <span class="entry-type">&gt;</span> <span class="entry-content">I see you need also need to add the index creation for the word alternatives like everything that we tried to add before in the DB in it file got lost and now we need to add it again</span></span><span class="entry code voice"><span class="entry-timestamp">23:28</span> <span class="entry-type">&gt;</span> <span class="entry-content">wait like now you&#39;re searching for index transcription words segment but like none of the indexes on the transcription stuff are defined in the DB in it file so you know maybe ignore the stuff about indexing first and just put that stuff about transcription changes in the file you know and then we can think about what which indexes we need</span></span><span class="entry code voice"><span class="entry-timestamp">23:29</span> <span class="entry-type">&gt;</span> <span class="entry-content">yeah okay just a transcription change also needs to be triggered when there is a change in the word alternatives and then yeah create indexes</span></span><span class="entry code voice"><span class="entry-timestamp">23:30</span> <span class="entry-type">&gt;</span> <span class="entry-content">I think in the transcription change notify when you build JSON object I don&#39;t know if we should include the is final thing there because I think in the UI we&#39;ll just you know do whatever we need to do although it is a bit weird I guess I&#39;m not sure how we&#39;re doing this in the UI but yeah</span></span><span class="entry code voice"><span class="entry-timestamp">23:38</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay I think when we upsert transcription segment when it&#39;s not a final then we should also clear the words that we have for that segment although this seems a bit bad but yeah</span></span><span class="entry code voice"><span class="entry-timestamp">23:41</span> <span class="entry-type">&gt;</span> <span class="entry-content">yeah you know I think actually versioning seems good I guess that means like that when we yeah when we upsert the segment we should increment revision number on the segment when we&#39;re updating and then we need to have that column also in the transcription word table and then we&#39;ll like or maybe we don&#39;t need to have the version as a field in the segment maybe we can have that in the word table only and then like when we update the UI or whatever we need to like only get the one with the latest version that might also be in the query</span></span><span class="entry code voice"><span class="entry-timestamp">23:43</span> <span class="entry-type">&gt;</span> <span class="entry-content">let&#39;s make it so that the upsert function returns the max version for the segment or you know it returns the version to use</span></span><span class="entry code voice"><span class="entry-timestamp">23:45</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay the query for upsert transcription segment needs to change in accordance with what we&#39;ve done now so it returns only the segment ID and the version</span></span><span class="entry code voice"><span class="entry-timestamp">23:46</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay I don&#39;t know SQLC doesn&#39;t like that syntax for the query of upsert transcription segment uh I&#39;m not sure why that is but okay</span></span><span class="entry code voice"><span class="entry-timestamp">23:48</span> <span class="entry-type">&gt;</span> <span class="entry-content">oh and there was a mix-up earlier and now we have like both in the queries file and in the DB init file we have a bunch of stuff about creating indexes and the function about notifications and stuff and that stuff should only be in the DB init file and yeah maybe the stuff that we have in the init file now is good enough</span></span><span class="entry code voice"><span class="entry-timestamp">23:50</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay now SQLC complains about there not being a segment ID column in the upsert transcription segment query I guess SQLC doesn&#39;t understand from the schema file that the upsert function returns a table with those columns</span></span><span class="entry code voice"><span class="entry-timestamp">23:51</span> <span class="entry-type">&gt;</span> <span class="entry-content">that actually still doesn&#39;t work I&#39;m not sure how to do this</span></span><span class="entry code voice"><span class="entry-timestamp">23:52</span> <span class="entry-type">&gt;</span> <span class="entry-content">in the queries file we have upsert transcription segment that selects two columns from the result of calling a function which is defined in the DB init file however SQLC doesn&#39;t understand that there is a column in the result called the segment ID and I&#39;m not sure how to solve this</span></span><span class="entry code voice"><span class="entry-timestamp">23:54</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay um in the schema file when you uh replace functions um I think you can&#39;t use create or replace function right now because uh it says it can&#39;t change the return type of an existing function so I guess you have to just like look if the function is defined and if so delete it and then create it</span></span><span class="entry code voice"><span class="entry-timestamp">23:56</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay it compiles now but at runtime we get an error in the upsert function that segment ID is ambiguous I guess that maybe is because there is the return column called segment ID and also we&#39;re using segment ID like in a select statement so I guess there you need to use a qualified notation</span></span><span class="entry code voice"><span class="entry-timestamp">23:58</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay I think you uh fixed that for the session ID but I mean we need to do it for the segment ID</span></span><span class="entry code voice"><span class="entry-timestamp">23:59</span> <span class="entry-type">&gt;</span> <span class="entry-content">also when you create the triggers that also needs to you know um because this fails now when the trigger already exists</span></span><span class="entry code voice"><span class="entry-timestamp">00:01</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay um I don&#39;t have the version column on my transcription words table um can you um just give me the SQL statement to run to um like as a migration</span></span><span class="entry code voice"><span class="entry-timestamp">00:12</span> <span class="entry-type">&gt;</span> <span class="entry-content">and the notify transcription change function we need to include is final in the JSON object and we need to get that from the segment</span></span><span class="entry code voice"><span class="entry-timestamp">00:15</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay I&#39;m seeing a lot of duplicates um when we make a new segment I&#39;m seeing duplicates in the UI I suspect this might be because the notification is happening too many times so I wonder like I bet that the notification now is triggered like every time the word like well I&#39;m not sure why exactly but um yeah and what do we do about it what do we do about it um well maybe let&#39;s say we put a version column in the transcription segment or you know latest version and then we increment that increment that when we you know change the word alternatives whatever so then we don&#39;t need to trigger on the world word alternative change because we&#39;ll already get the notification from the changing the version column in the transcription segment</span></span><span class="entry code voice"><span class="entry-timestamp">00:16</span> <span class="entry-type">&gt;</span> <span class="entry-content">great can you now also create a migration file for um adding the column and also for deleting the trigger that we don&#39;t need anymore</span></span><span class="entry code voice"><span class="entry-timestamp">00:17</span> <span class="entry-type">&gt;</span> <span class="entry-content">actually in the migration you could set the version to the max version of any words in that segment</span></span><span class="entry code voice"><span class="entry-timestamp">00:18</span> <span class="entry-type">&gt;</span> <span class="entry-content">can you put the index creation in the init file instead of in the migration</span></span><span class="entry code voice"><span class="entry-timestamp">00:19</span> <span class="entry-type">&gt;</span> <span class="entry-content">wait no the migration i&#39;m talking about uh it should add the version column to the segments table</span></span><span class="entry code voice"><span class="entry-timestamp">00:19</span> <span class="entry-type">&gt;</span> <span class="entry-content">yeah and that should set the version to the max version of words for each segment</span></span><span class="entry code voice"><span class="entry-timestamp">00:23</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay um the version column name in the upsert transcription segment function is ambiguous in some places we need to use qualified axis for that</span></span><span class="entry code voice"><span class="entry-timestamp">00:33</span> <span class="entry-type">&gt;</span> <span class="entry-content">uh the get transcript segment query i think uh should um use the version column of this segment uh to choose the words</span></span><span class="entry code voice"><span class="entry-timestamp">00:35</span> <span class="entry-type">&gt;</span> <span class="entry-content">and also um let&#39;s make it return only the top um you know the highest confidence word alternative for every word</span></span><span class="entry code voice"><span class="entry-timestamp">00:43</span> <span class="entry-type">&gt;</span> <span class="entry-content">can you make an sql file um that just somehow um shows me the transcription segments like from the latest session maybe and like for each segment it should show like well you know it should show like the word it should show the words in each segment in some kind of way like so they&#39;re gonna see like all the word alternatives and stuff</span></span><span class="entry code voice"><span class="entry-timestamp">00:45</span> <span class="entry-type">&gt;</span> <span class="entry-content">um make that query show only the um show only the words from the current version of the segment and like somehow show it in a nicer way so that i can see what&#39;s going on</span></span><div class="date">Sunday, 4 August</div><span class="entry code voice"><span class="entry-timestamp">00:53</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay we need to add a column to the transcription words table namely attaches to um and uh so like when we insert transcription word and handle transcript we need to insert that as well and um yeah then when we when we um you know when we get the transcript segment those uh rows also need to have that column</span></span><span class="entry code voice"><span class="entry-timestamp">00:55</span> <span class="entry-type">&gt;</span> <span class="entry-content">can you also update the db init file so that it reflects the uh migration in other words so that the words table has the new column and you might as well create the index in the init file as well if it doesn&#39;t exist</span></span><span class="entry code voice"><span class="entry-timestamp">01:09</span> <span class="entry-type">&gt;</span> <span class="entry-content">make the show latest transcription query return the word alternatives in their own rows while still you know selecting the same set</span></span><span class="entry code voice"><span class="entry-timestamp">01:29</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay so now i want to do something which is um so we have a command now um stream transcribe ui we need to split this up so that there is like a uh a command that&#39;s just called transcribe which does nothing with the user interface it just um you know um listens for packets and um updates the database with transcription stuff so and then the the ui for watching the transcription stuff will be a separate command</span></span><span class="entry code voice"><span class="entry-timestamp">01:30</span> <span class="entry-type">&gt;</span> <span class="entry-content">oops i think he put some placeholders in the code like where he says rest of the function similar to um we need to um fix that and like refactor it to like properly split this functionality into the server commands</span></span><span class="entry code voice"><span class="entry-timestamp">01:32</span> <span class="entry-type">&gt;</span> <span class="entry-content">yeah okay but now there&#39;s this function called handle stream with transcription and ui uh we don&#39;t need that anymore but like that has the correct audio format specification um so i think you need to like uh like the handle stream with transcription thing you need to like i don&#39;t know copy over most of the stuff from that handle blah blah and ui function into yeah well you know what i mean</span></span><span class="entry code voice"><span class="entry-timestamp">02:21</span> <span class="entry-type">&gt;</span> <span class="entry-content">all right i think i might have an idea of a problem so in listen for transcription changes we do wait for notification however um um i think there is a risk that we miss some notifications because you know if it takes time to send the update to the update channel then um i think a notification might happen you know in between so i think maybe we should make the update chan into a bounded channel so that you can send to it immediately right</span></span><span class="entry code voice"><span class="entry-timestamp">02:22</span> <span class="entry-type">&gt;</span> <span class="entry-content">and how do you know if like uh we drop back or drop an update to the update chan because somehow it&#39;s not being read</span></span><span class="entry code voice"><span class="entry-timestamp">02:27</span> <span class="entry-type">&gt;</span> <span class="entry-content">oh i think i see the issue uh in handle transcript in <tt>tts.go</tt> we do the upsert and then we do the insert transcription word but um the trigger is going to be triggered when we do the upsert and then when we look uh in the ui there will not be any words because that happens later so like um i think we should yeah we should use we should the handle transcript should uh run in a transaction</span></span><span class="entry code voice"><span class="entry-timestamp">02:30</span> <span class="entry-type">&gt;</span> <span class="entry-content">um okay that&#39;s not how transactions work um we need to uh we need to in handle transcript we need access to the actual uh database connection or the underlying connection pool or whatever somehow and then we need to use um we need to use begin and to get a new transaction you know we do pgx pool dot begin um yeah so and then you know queries dot with tx takes the transaction as a parameter and returns a new version of the queries</span></span><span class="entry"><span class="entry-timestamp">02:35</span> <span class="entry-type">+</span> <span class="entry-content"><tt>snd/ogg.go</tt></span></span><span class="entry code voice"><span class="entry-timestamp">02:37</span> <span class="entry-type">&gt;</span> <span class="entry-content">if you look at write packet in the <tt>aug.go</tt> file there seems to be something wrong with how the packet timestamps are handled after uh gap insertion it seems to me that um when we set the last timestamped and last packet timestamp at the end of that function um we are not considering that we might have added gap</span></span><span class="entry code voice"><span class="entry-timestamp">02:38</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay but now we are overwriting that last packet timestamp again at the end of the function</span></span><span class="entry code voice"><span class="entry-timestamp">02:39</span> <span class="entry-type">&gt;</span> <span class="entry-content">uh that&#39;s so weird like we always need to update the last packet timestamp and stuff when we write a packet it&#39;s just that i mean i think you can in the gap duration part of that function you can just modify the packet created at in timestamps so that yeah</span></span><span class="entry code voice"><span class="entry-timestamp">02:48</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay look in write rtp packet you see that we use the segment number multiplied by 960 uh for the timestamp uh this is because um so there&#39;s an issue with overflowing timestamps they&#39;re supposed to overflow and wrap back to zero but we still need to be able to know so but we are not dealing with these things properly so i think that like um we can&#39;t just use the timestamps here to um all right we can&#39;t just look at the timestamps like when we calculate gap durations because the packet timestamp can overflow so so we need to just use the segment number thingy</span></span><span class="entry code voice"><span class="entry-timestamp">02:51</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay um now we have sequence number and segment number i don&#39;t think we need to have that i think we can remove the thing that&#39;s called the sequence number and i think we should have this segment number as a you know in 64 you in 64 and um yeah i don&#39;t know</span></span><span class="entry code voice"><span class="entry-timestamp">02:58</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay uh now in the ui we have the model struct with transcript stuff but the thing is we might have several concurrent transcription sessions and we want to be able to show them in the same ui but we need to process them separately so maybe you know we would have um the model would have like a map from session id to like the transcript info i mean final transcripts and current transcript and then we would need to like make the thing that updates based on transcript messages we need to make that do it you know specifically for the relevant session and then when we um uh create the viewport content we need to do that by um well we need to also do that separated by the uh session ids and so we need to use you know separate word builders for those uh but it&#39;s a bit weird because then we want to interleave the lines in the viewport based on uh timing the start time like the first start time of each thing so um that&#39;s a bit weird i think we need a bit different structure</span></span><span class="entry code voice"><span class="entry-timestamp">03:06</span> <span class="entry-type">&gt;</span> <span class="entry-content">uh i was changing that around a bit to try to fix it but actually i think we will need to make it so that the thing called word builder actually creates the lines structures um so when you append words it should take care of doing the lines stuff</span></span><span class="entry code voice"><span class="entry-timestamp">03:24</span> <span class="entry-type">&gt;</span> <span class="entry-content">could you try to make a test file for the ui um for now i want you to just test one thing and that is the transcript view method of the model you&#39;ll have to export that i guess or maybe not because it&#39;ll be in the same package i don&#39;t know but um yeah so and i want to test transcript view with a simple test case involving two sessions wait first just do one session with like one final transcript and like something in the current transcript and just see if this string gives back is correct</span></span><span class="entry code voice"><span class="entry-timestamp">03:38</span> <span class="entry-type">&gt;</span> <span class="entry-content">can you add a new transcript view test case that does that has two sessions and showing that they interleave properly based on the times</span></span><span class="entry code voice"><span class="entry-timestamp">03:40</span> <span class="entry-type">&gt;</span> <span class="entry-content">uh actually in order to do the interleaving you need to have um eos words in the transcripts otherwise you don&#39;t get more than one line per session and it&#39;s the lines that are sorted</span></span><span class="entry code voice"><span class="entry-timestamp">03:43</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay first of all refactor this test thing by making it easier to build up the model structure like maybe you could have functions in the test file for like adding transcripts to a given session or something so that you know the test cases look more like you know add this transcript add this current add this add this and then also please in the two session test case uh don&#39;t have all these words like just put like a b 1 2 as the words or something you know it doesn&#39;t make it easier to scan</span></span><span class="entry code voice"><span class="entry-timestamp">03:47</span> <span class="entry-type">&gt;</span> <span class="entry-content">maybe use var args variable arguments you know for the add final transcript and set current transcript and maybe maybe make the new test model thing return uh struct that&#39;s like a type alias for the model and then add final transcript can be a method on that type alias</span></span><span class="entry code voice"><span class="entry-timestamp">03:48</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay and uh don&#39;t worry about the confidence so the new word function doesn&#39;t need to take confidence just set the confidence to one</span></span><span class="entry code"><span class="entry-timestamp">04:15</span> <span class="entry-type">&gt;</span> <span class="entry-content">/commit</span></span><span class="entry code voice"><span class="entry-timestamp">04:15</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay can you now add a test case where you um use the attaches to previous thing you&#39;re going to use that with um a word that&#39;s just a period because that&#39;s how it normally is</span></span><span class="entry"><span class="entry-timestamp">04:17</span> <span class="entry-type">+</span> <span class="entry-content"><tt>db/queries.sql</tt></span></span><span class="entry"><span class="entry-timestamp">04:17</span> <span class="entry-type">+</span> <span class="entry-content"><tt>db/db_init.sql</tt></span></span><span class="entry code voice"><span class="entry-timestamp">04:18</span> <span class="entry-type">&gt;</span> <span class="entry-content">now can you make it so that when you start the ui with a stream command it should find for the past hour let&#39;s say regardless of session and show all of those at first and then you know stream</span></span><span class="entry ask voice"><span class="entry-timestamp">06:02</span> <span class="entry-type">?</span> <span class="entry-content">hey i&#39;m thinking of uh writing a test suite for the og stuff and i wonder can you look through that stuff and tell me like uh where does it use things that are not immediately testable or nicely testable i mean like depending on the current time of the system or also like i guess like using libraries that actually write the og stuff like we would want to mock that out</span></span><span class="entry ask voice"><span class="entry-timestamp">06:04</span> <span class="entry-type">?</span> <span class="entry-content">yeah i would also want to create an interface for og writer so that i can also use a mock for that so that i don&#39;t need to check the binary but you know the mock would just um create an array of the like the four things from the create rtp packet so the sequence number timestamp ssrc and the payload</span></span><span class="entry code voice"><span class="entry-timestamp">06:05</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay let&#39;s try doing that and just like some super basic test case to get started</span></span><span class="entry"><span class="entry-timestamp">06:06</span> <span class="entry-type">+</span> <span class="entry-content"><tt>main.go</tt></span></span><span class="entry code voice"><span class="entry-timestamp">06:06</span> <span class="entry-type">&gt;</span> <span class="entry-content">now we need to update the call to new og in the main file</span></span><span class="entry code voice"><span class="entry-timestamp">06:06</span> <span class="entry-type">&gt;</span> <span class="entry-content">yeah please implement the new og writer and the real-time provider</span></span><span class="entry"><span class="entry-timestamp">06:09</span> <span class="entry-type">+</span> <span class="entry-content"><tt>tts/tts.go</tt></span></span><span class="entry code voice"><span class="entry-timestamp">06:09</span> <span class="entry-type">&gt;</span> <span class="entry-content">also update the <tt>tts.go</tt> file where we create the new og</span></span><span class="entry"><span class="entry-timestamp">06:17</span> <span class="entry-type">+</span> <span class="entry-content"><tt>tts/ui_test.go</tt></span></span><span class="entry"><span class="entry-timestamp">06:17</span> <span class="entry-type">-</span> <span class="entry-content"><tt>ogg/stream.go</tt></span></span><span class="entry"><span class="entry-timestamp">06:17</span> <span class="entry-type">+</span> <span class="entry-content"><tt>snd/stream.go</tt></span></span><span class="entry code voice"><span class="entry-timestamp">06:18</span> <span class="entry-type">&gt;</span> <span class="entry-content">in the ui test can you change the test cases so that they don&#39;t use decimal seconds um just use whole seconds and then um in the expected strings you should include the parenthesized three-part timestamps</span></span><span class="entry code voice"><span class="entry-timestamp">06:19</span> <span class="entry-type">&gt;</span> <span class="entry-content">and now in the og test can you make a test case that demonstrates the silence insertion gap insertion</span></span><span class="entry code voice"><span class="entry-timestamp">06:23</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay the test case is failing i think you&#39;re not counting the packets that you expect correctly because like if you had if you have a one-second gap then that&#39;ll create like as many packets as you need to fill one second with 20 millisecond packets</span></span><span class="entry code voice"><span class="entry-timestamp">06:43</span> <span class="entry-type">&gt;</span> <span class="entry-content">um the gap insertion in the og module i think is not working properly because it&#39;s doing the diff calculation based on just the segment number things but like what actually happened when we get a gap is like discord sends a stream where the segment numbers are monotonic you know they go up by one but the timestamp of the packet can like jump for any amount of time and that just means the user wasn&#39;t talking so you know i think we need i think we need to instead like uh predict like okay what would be the uh well so based on the created at of the packet and the packet&#39;s timestamp like that&#39;s what we should use to figure out what to do with the handle gap thing</span></span><span class="entry code voice"><span class="entry-timestamp">06:48</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay now i see that it prints audio gap detected gap duration 2.98 seconds but i&#39;m expecting three seconds there i guess or something so silent frames is 149 but we&#39;re expecting 150 i&#39;m not sure what&#39;s wrong</span></span><span class="entry code voice"><span class="entry-timestamp">07:12</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay i got the test to pass now um could you try to um look through the relevant code in the <tt>ogg.go</tt> file and uh just refactor it you know make it easier to understand because it&#39;s hard to follow it&#39;s hard to understand what all the fields and variables are for</span></span><span class="entry code voice"><span class="entry-timestamp">07:15</span> <span class="entry-type">&gt;</span> <span class="entry-content">it&#39;s still hard to understand like the purpose of for example um the fields like packet count first time stamp last time stamp uh you know like it&#39;s hard to understand how exactly these things are used to to determine the expected timestamps and the various offsets and stuff i&#39;m not sure how to make that more clear but there has to be some like conceptual improvement</span></span><span class="entry code voice"><span class="entry-timestamp">07:18</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay um it&#39;s also not clear how um the initial silence thing differs from the gap thing aren&#39;t those doing basically the same kind of thing i feel like it should be possible to unify this</span></span><span class="entry code voice"><span class="entry-timestamp">07:21</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay and it&#39;s not clear why we track the packet count and also the segment number</span></span><span class="entry code voice"><span class="entry-timestamp">07:24</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay it&#39;s getting pretty good um would you go through and just like reorder the fields instruct to be uh you know nicer and more like standard so you&#39;d have the logger on top um you know and then like groups things in a reasonable way um uh what else yeah and like see if you can just like come up with some helper functions to make the calculations easier to read and understand you know so it becomes like really really conceptually clear what&#39;s going on</span></span><span class="entry code voice"><span class="entry-timestamp">07:26</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay interesting uh with that last change when i rerun the tests they fail it says expected 252 packets got 152 so and also it says expected silent packet at index zero so something is not right with the first um um well something is not right with this silence insertion</span></span><span class="entry code voice"><span class="entry-timestamp">07:30</span> <span class="entry-type">&gt;</span> <span class="entry-content">yeah i had to change that back a bit you were forgetting about the 20 milliseconds of the first actual packet but anyway it&#39;s hard to understand the test case could you make that easier to understand you know like it&#39;s hard to understand where 152 comes from</span></span><span class="entry code"><span class="entry-timestamp">07:33</span> <span class="entry-type">&gt;</span> <span class="entry-content">Expected timestamp difference of 240960, got 289920 delta 51.000000 sec </span></span><span class="entry code"><span class="entry-timestamp">07:34</span> <span class="entry-type">&gt;</span> <span class="entry-content">Expected timestamp difference of 240000, got 289920 delta 1.040000 sec </span></span><span class="entry code"><span class="entry-timestamp">07:34</span> <span class="entry-type">&gt;</span> <span class="entry-content"><tt>ogg_test.go:203:</tt> Expected timestamp difference of 144000, got 289920 delta 3.040000 sec </span></span><span class="entry code voice"><span class="entry-timestamp">07:38</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay can you now try making another test case let&#39;s make one that uses um a real aug writer that writes to like a temporary file or whatever and we can make it only have maybe like silent packets and um then when the file is written it should shell out to the program called Opus what is it called um Opus info and it should try to use and it should try to use yeah i mean i should just see if that succeeds</span></span><span class="entry code voice"><span class="entry-timestamp">07:44</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay cool um i see some warnings from Opus info it says sample count behind granule many times and the difference the first time is 960 and the difference the second time is 1920 um um yeah well there&#39;s something weird going on there it also says pre-skip 3840 so i&#39;m not sure</span></span><span class="entry"><span class="entry-timestamp">07:47</span> <span class="entry-type">undo</span> </span><span class="entry code voice"><span class="entry-timestamp">09:07</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay kind of just one more thing now i think in the test suite when you write to a file we shouldn&#39;t use um we shouldn&#39;t use aug.newwith because that marks it as a stream instead of a file um we need to use <tt>aug.new</tt> and so we need like something that&#39;s like new aug writer but just like new aug file in <tt>aug.go</tt></span></span><span class="entry code voice"><span class="entry-timestamp">10:08</span> <span class="entry-type">&gt;</span> <span class="entry-content">i added four interface types at the top of <tt>stream.go</tt> could you refactor that file to work with such interfaces instead of having concrete references to external types you know to make it easier to test and stuff</span></span><span class="entry code voice"><span class="entry-timestamp">10:10</span> <span class="entry-type">&gt;</span> <span class="entry-content">uh somehow the stream opus packets function uh got lost um also demux opus packets maybe that was intentional maybe i should do it in another way but like in <tt>main.go</tt> and <tt>tts.go</tt> we have to update in that case or you can add them back i don&#39;t know</span></span><span class="entry"><span class="entry-timestamp">10:11</span> <span class="entry-type">$</span> <span class="entry-content">make build</span></span><span class="entry code voice"><span class="entry-timestamp">10:13</span> <span class="entry-type">&gt;</span> <span class="entry-content">uh it&#39;s been weird how we&#39;re creating new posters pools all over the place now isn&#39;t there a better way to deal with that</span></span><span class="entry"><span class="entry-timestamp">10:14</span> <span class="entry-type">$</span> <span class="entry-content">make build</span></span><span class="entry"><span class="entry-timestamp">10:15</span> <span class="entry-type">+</span> <span class="entry-content"><tt>db/postgres.go</tt></span></span><span class="entry code voice"><span class="entry-timestamp">10:15</span> <span class="entry-type">&gt;</span> <span class="entry-content">uh it&#39;s still a bit weird i think like uh in the db package we have a database opening function uh we should use that and that should like cache it so it&#39;s a singleton something like that right</span></span><span class="entry ask"><span class="entry-timestamp">10:20</span> <span class="entry-type">?</span> <span class="entry-content">now can you think about how to do some basic high yield refactoring or restructuring of <tt>tts/tts.go</tt>? it&#39;s quite large and it has some very long functions</span></span><span class="entry code"><span class="entry-timestamp">10:21</span> <span class="entry-type">&gt;</span> <span class="entry-content">please implement these changes</span></span><span class="entry code"><span class="entry-timestamp">10:23</span> <span class="entry-type">&gt;</span> <span class="entry-content">now put back the <tt>handleTranscriptionUpdate,</tt> <tt>formatTranscriptWords,</tt> etc</span></span><span class="entry"><span class="entry-timestamp">10:25</span> <span class="entry-type">$</span> <span class="entry-content">make build</span></span><span class="entry"><span class="entry-timestamp">10:26</span> <span class="entry-type">+</span> <span class="entry-content"><tt>db/queries.sql</tt></span></span><span class="entry"><span class="entry-timestamp">10:27</span> <span class="entry-type">$</span> <span class="entry-content">make build</span></span><span class="entry code voice"><span class="entry-timestamp">10:36</span> <span class="entry-type">&gt;</span> <span class="entry-content">in <tt>tts.go</tt> and other files there it&#39;s hard to understand like the difference between all the different structs like transcript word transcript message um we&#39;re converting from <tt>getTranscriptSegmentRow</tt> into transcript word i mean it&#39;s not bad it&#39;s just hard to understand um and your eyes kind of glaze over with all these very similar types with a bit vague names</span></span><span class="entry code voice"><span class="entry-timestamp">10:39</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay um another thing that&#39;s a bit confusing is transcript word has start time and time and real start time and the start time and time are like relative to the beginning of the session and the real start time is like the absolute time but it&#39;s a bit confusing</span></span><span class="entry code voice"><span class="entry-timestamp">10:42</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay now i think there&#39;s some stuff in <tt>ui.go</tt> that could be um refactored a bit uh or like some stuff&#39;s gonna be extracted into maybe like the models file or something for example uh the thing where we&#39;re converting from the uh transcripts from last hour row into transcript words transcript segment that kind of thing i think could be extracted out also it shouldn&#39;t be called <tt>getTranscript</tt> for the last hour it&#39;s weird</span></span><span class="entry code voice"><span class="entry-timestamp">10:47</span> <span class="entry-type">&gt;</span> <span class="entry-content">the queries <tt>getTranscripts</tt> and <tt>getTranscriptsSegment</tt> um have basically the same return type but they&#39;re different structs because well sqlc generates different structs for them there might be some super minor difference but i think uh we should merge them into a single query um and like it should accept a nullable id parameter and if it&#39;s null then you do use the created instead something like that</span></span><span class="entry code"><span class="entry-timestamp">10:50</span> <span class="entry-type">&gt;</span> <span class="entry-content">/ask</span></span><span class="entry code voice"><span class="entry-timestamp">10:51</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay i think in the <tt>ui.go</tt> we could also move uh <tt>loadReasonTranscripts</tt> to like the models file or something</span></span><span class="entry code voice"><span class="entry-timestamp">10:57</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay here&#39;s an idea in <tt>ui.go</tt> we have this word builder thing and also we have the session transcript struct and um in the transcript view method on the model we iterate over the sessions map and use the word builder to get these lines okay my idea is we can uh abstract this a little bit uh first of all it shouldn&#39;t be called word builder it should be called something else like um well i don&#39;t know and it should work in a way work in a way like it should uh well okay yeah it should build up lines as a structure okay um i think the line info should have a content that consists of spans which is a new thing we&#39;ll define so that&#39;s like to abstract away the coloring and stuff and like instead of writing this string which is just a space we would have a span that&#39;s a space it&#39;s bound that represents a space and so then we would build up a structure like that so then uh we can test that quite easily and we could do that in the ui test file</span></span><span class="entry code voice"><span class="entry-timestamp">11:00</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay and now a nice thing to do would be since we have the transcript builder written in this way we can use temple t-e-m-p-l you know the nice um composable html templating module um to generate transcripts in html and um do that um and do like a basic test case for that</span></span><span class="entry code voice"><span class="entry-timestamp">11:01</span> <span class="entry-type">&gt;</span> <span class="entry-content">make a basic configuration file for the temple module</span></span><span class="entry"><span class="entry-timestamp">11:19</span> <span class="entry-type">+</span> <span class="entry-content"><tt>main.go</tt></span></span><span class="entry code voice"><span class="entry-timestamp">11:19</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay now make a new Cobra command called http which just um you know shows the past eight hours of transcripts or whatever using this these new html stuff that we&#39;ve made</span></span><span class="entry code voice"><span class="entry-timestamp">11:28</span> <span class="entry-type">&gt;</span> <span class="entry-content">okay let&#39;s refactor how we represent the spans so that we don&#39;t use lip gloss color values but our own thing which can only represent like the abstract colors that we need so that then in the template we can turn that into some css thing also use tailwind from the cdn and improve the styling</span></span><span class="entry"><span class="entry-timestamp">11:29</span> <span class="entry-type">$</span> <span class="entry-content">make build</span></span><span class="entry"><span class="entry-timestamp">11:30</span> <span class="entry-type">$</span> <span class="entry-content">make test</span></span><span class="entry code voice"><span class="entry-timestamp">11:34</span> <span class="entry-type">&gt;</span> <span class="entry-content">can you add a route uh in a somewhat nice almost rest like way uh which generates og files given um like a session id transcription session id and uh relative time spans or something or absolute whatever maybe rather and then make so that each line in the transcript has a link to that route with the og mime type</span></span><span class="entry"><span class="entry-timestamp">11:35</span> <span class="entry-type">$</span> <span class="entry-content">make build</span></span><span class="entry code voice"><span class="entry-timestamp">11:37</span> <span class="entry-type">&gt;</span> <span class="entry-content">i think all the links have a zero as the session id which indicates that that field is not being filled properly somewhere</span></span><span class="entry code voice"><span class="entry-timestamp">11:39</span> <span class="entry-type">&gt;</span> <span class="entry-content">there&#39;s still zero everywhere</span></span><span class="entry voice"><span class="entry-timestamp">12:09</span> <span class="entry-type">+</span> <span class="entry-content"><tt>bot/bot.go</tt></span></span><span class="entry code"><span class="entry-timestamp">12:09</span> <span class="entry-type">&gt;</span> <span class="entry-content">hey let&#39;s make a <tt>README.md</tt> that&#39;s simple, straightforward, explanatory, describing what this system does, what it depends on, and some basic instructions for how to get it working</span></span><span class="entry code"><span class="entry-timestamp">12:10</span> <span class="entry-type">&gt;</span> <span class="entry-content">change to AGPL-3.0-or-later license</span></span><span class="entry code voice"><span class="entry-timestamp">12:13</span> <span class="entry-type">&gt;</span> <span class="entry-content">explain that there are several commands explain that it like it saves all the opus audio in Postgres and then it can stream like arbitrary slices of that explain that the transcribe command will start transcribing using Speechmatics all the incoming audio with one transcription session per user per speaker explain that the stream command shows a terminal UI that&#39;s like a nice section with some you know like basic architecture like what&#39;s the structure and like how would you how do you find stuff in the code base and like what to be familiar with like SQL C for example</span></span><span class="entry code voice"><span class="entry-timestamp">12:18</span> <span class="entry-type">&gt;</span> <span class="entry-content">add SQL C generate and Temple generate to the makefile also add init target to the makefile mention that we use Speechmatics for real-time transcription and that we&#39;re going to use Google Gemini for like using their multimodal generative AI model to get even more accurate transcription results it&#39;s not real time okay make a little section that explains the database schema in like broad strokes it doesn&#39;t need to be exhausted or anything and add like a section that explains that is a very early stage thing and it&#39;s meant to be quite extensible and like a nice basis for making bots so currently it doesn&#39;t like respond to users in discord but it&#39;s going to be like a like my idea for what I wanted to be is like a kind of secretary it&#39;s like keeping track of everything can find previous conversations and can like step in to help you if it sees that you&#39;re asking asking you to look up something or you know so it&#39;s not exactly like a chatbot in the sense that it&#39;s not like constantly replying but it&#39;s more like it&#39;s there if you need it anyway it&#39;s meant to be like kind of pluggable but yeah</span></span><span class="entry code voice"><span class="entry-timestamp">12:19</span> <span class="entry-type">&gt;</span> <span class="entry-content">Maybe add also a section about how we use the AIDR, A-I-D-E-R, coding agent with CLAWD 3.5, SONNET, for doing most of the developing work, so you can check out AIDR.chat, it&#39;s their website. And then generally just like rewrite the readme sections to be a bit more somehow, I don&#39;t know, interesting, somewhat captivating, a little bit funny maybe, use some emojis, doesn&#39;t need to be like super stereotypical.</span></span><span class="entry code voice"><span class="entry-timestamp">12:23</span> <span class="entry-type">&gt;</span> <span class="entry-content">Okay, make this style a little bit more literary and like literate, and not this like light-hearted <tt>GitHub</tt> nerd style, more like a somewhat unconventional, like you can&#39;t really tell if it&#39;s completely serious or if it&#39;s a bit like tummy cheek, but still like a nice pleasant style that kind of keeps intelligent people reading, a little bit narrative, a little bit like, I don&#39;t know.</span></span><span class="entry"><span class="entry-timestamp">12:26</span> <span class="entry-type">undo</span> </span><span class="entry"><span class="entry-timestamp">13:33</span> <span class="entry-type">+</span> <span class="entry-content"><tt>prolog.go</tt></span></span><span class="entry code"><span class="entry-timestamp">13:34</span> <span class="entry-type">&gt;</span> <span class="entry-content">try implementing similar to the <tt>ExampleRegister</tt> function in <tt>prolog.go</tt> but it should register a function that lets you do some db query</span></span><span class="entry code"><span class="entry-timestamp">13:34</span> <span class="entry-type">&gt;</span> <span class="entry-content">do it in <tt>prolog.go</tt> please</span></span><span class="entry code"><span class="entry-timestamp">13:35</span> <span class="entry-type">&gt;</span> <span class="entry-content">make a simple bubble tui and command <tt>jamie</tt> <tt>prolog</tt> with a simple prolog repl</span></span><span class="entry code"><span class="entry-timestamp">13:36</span> <span class="entry-type">&gt;</span> <span class="entry-content">fix the placeholder stuff in <tt>prolog.go</tt></span></span><span class="entry code"><span class="entry-timestamp">13:36</span> <span class="entry-type">&gt;</span> <span class="entry-content">move the <tt>registerDBQuery</tt> function to <tt>prolog.go</tt> </span></span><span class="entry code"><span class="entry-timestamp">13:42</span> <span class="entry-type">&gt;</span> <span class="entry-content">fix the registered predicate so you call it like <tt>last_joined_channel</tt> &#34;123412341234&#34;, <tt>ChannelID</tt> , so <tt>GuildID</tt> is in and <tt>ChannelID</tt> is out</span></span><span class="entry code"><span class="entry-timestamp">14:00</span> <span class="entry-type">&gt;</span> <span class="entry-content">now add a predicate <tt>known_guild</tt> Id that unifies Id with any known guild from let&#39;s say the <tt>ssrc_mappings</tt> table, it should do this in the registered predicate by using standard prolog like member Id, Guilds where Guilds is a slice of trealla.Atom &#34;1231232&#34; </span></span><span class="entry code"><span class="entry-timestamp">14:10</span> <span class="entry-type">&gt;</span> <span class="entry-content">make the repl more classic with a text input on the bottom and results in a viewport</span></span><span class="entry code"><span class="entry-timestamp">14:13</span> <span class="entry-type">&gt;</span> <span class="entry-content">when you query it should use .Query and not <tt>.QueryOnce</tt> and that gives us a Query which we should save in the state to iterate over in classic prolog fashion with key , to get next solution with .Next ctx bool true if got, .Current gets the answer, .Err check after iterating, .Close </span></span><span class="entry code"><span class="entry-timestamp">14:35</span> <span class="entry-type">&gt;</span> <span class="entry-content">when there is an active query in the repl it should feel like a mode so it doesn&#39;t show the text input anymore, instead it shows some kind of button menu for next and abort?</span></span><span class="entry code"><span class="entry-timestamp">14:38</span> <span class="entry-type">&gt;</span> <span class="entry-content">we should use tea cmds for updates like the n button should return a cmd that does the <tt>iterateQuery</tt> thing</span></span><span class="entry code"><span class="entry-timestamp">14:40</span> <span class="entry-type">&gt;</span> <span class="entry-content">ok now also for enter and a</span></span><span class="entry code"><span class="entry-timestamp">15:04</span> <span class="entry-type">&gt;</span> <span class="entry-content">/drop</span></span><span class="entry"><span class="entry-timestamp">15:04</span> <span class="entry-type">+</span> <span class="entry-content"><tt>prolog_repl.go</tt></span></span><span class="entry code"><span class="entry-timestamp">15:05</span> <span class="entry-type">&gt;</span> <span class="entry-content">extract a function to do the iterate query, so we can do it also once when we first start the query, also use lipgloss to make everything look dank like turbo pascal</span></span><span class="entry code"><span class="entry-timestamp">15:13</span> <span class="entry-type">&gt;</span> <span class="entry-content">use lipgloss borders and paddings and background colors and stuff to make it really look like a futuristic vaporwave version of turbo pascal</span></span><span class="entry code"><span class="entry-timestamp">15:18</span> <span class="entry-type">&gt;</span> <span class="entry-content">the color scheme should be more pascalish, with nonblack background colors like blue and grey, and the border styling should be improved signficantly</span></span><span class="entry"><span class="entry-timestamp">16:37</span> <span class="entry-type">+</span> <span class="entry-content"><tt>prolog.go</tt></span></span><span class="entry"><span class="entry-timestamp">16:37</span> <span class="entry-type">+</span> <span class="entry-content"><tt>db/queries.sql</tt></span></span><span class="entry"><span class="entry-timestamp">16:37</span> <span class="entry-type">+</span> <span class="entry-content"><tt>main.go</tt></span></span><span class="entry code"><span class="entry-timestamp">16:40</span> <span class="entry-type">&gt;</span> <span class="entry-content">add a prolog predicate that can fetch the recent transcription words as a list of terms like word Time, Text </span></span><span class="entry code"><span class="entry-timestamp">16:45</span> <span class="entry-type">&gt;</span> <span class="entry-content">make it so variables that start with _ like _L are not shown in the solutions list in the repl</span></span><span class="entry code"><span class="entry-timestamp">22:30</span> <span class="entry-type">&gt;</span> <span class="entry-content">hey i&#39;m working on a thing to render your very own log file to html, i want you to introduce a processing step after the parser, which divides the entries into a two level hierarchy based on timing, like if there&#39;s more than 10 minutes between two entries you make a new section, if there&#39;s more than 1 hour you make a new article, and make the template render accordingly</span></span><span class="entry code"><span class="entry-timestamp">22:32</span> <span class="entry-type">&gt;</span> <span class="entry-content">make the styling way less blatant, no need for headings even, just vertical spacing, rhythmic and typographically correct, but dense and crisp like berkeley graphics, no round corners or shadows</span></span><span class="entry code"><span class="entry-timestamp">22:37</span> <span class="entry-type">&gt;</span> <span class="entry-content">format the dates like &#34;Tuesday, 2 August, 2024&#34; and only show timestamps above each section, or wait use a layout where the dates and times are a bit like side notes in a left column, and make the typography tighter, no hr rules</span></span><span class="entry code"><span class="entry-timestamp">22:38</span> <span class="entry-type">&gt;</span> <span class="entry-content">put the timestamps also in the left column</span></span><span class="entry code"><span class="entry-timestamp">22:38</span> <span class="entry-type">&gt;</span> <span class="entry-content">split the template into several subtemplate functions</span></span><span class="entry code"><span class="entry-timestamp">22:39</span> <span class="entry-type">&gt;</span> <span class="entry-content">hmm rendering the columns separately doesn&#39;t really make sense because you can&#39;t align them correctly</span></span><span class="entry code"><span class="entry-timestamp">22:43</span> <span class="entry-type">&gt;</span> <span class="entry-content">only show the date when it changes otherwise make it invisible but keep the spacing</span></span><span class="entry code"><span class="entry-timestamp">22:49</span> <span class="entry-type">&gt;</span> <span class="entry-content">make the processor set <tt>article.NewDay</tt> true when the day switches and use that in the template instead</span></span><span class="entry code"><span class="entry-timestamp">22:52</span> <span class="entry-type">&gt;</span> <span class="entry-content">support dark mode in css with background black, color ivory</span></span><span class="entry"><span class="entry-timestamp">23:47</span> <span class="entry-type">+</span> <span class="entry-content"><tt>tts/http_cmd.go</tt></span></span><span class="entry code"><span class="entry-timestamp">23:54</span> <span class="entry-type">&gt;</span> <span class="entry-content">let&#39;s refactor the <tt>HTTPCmd</tt> stuff by moving the core server stuff to <tt>jamie/http/serve.go</tt> and we can make some kind of setup where different packages can add their own routes with init functions with <tt>http.HandleFunc,</tt> so make the tts thing do that, and make it serve stuff under /tts/, then make /aider/ to serve the aiderdoc</span></span><span class="entry code"><span class="entry-timestamp">23:56</span> <span class="entry-type">&gt;</span> <span class="entry-content">just write to <tt>http/serve.go</tt> dude</span></span><span class="entry"><span class="entry-timestamp">23:57</span> <span class="entry-type">+</span> <span class="entry-content"><tt>tts/transcript_template.templ</tt></span></span><span class="entry code"><span class="entry-timestamp">23:57</span> <span class="entry-type">&gt;</span> <span class="entry-content">also update the transcript template if necessary</span></span><span class="entry code"><span class="entry-timestamp">00:13</span> <span class="entry-type">&gt;</span> <span class="entry-content">instead of using init to register routes, make public functions called Routes that take Mux or whatever thingies plus db queries, so we&#39;re more explicit and legible</span></span><span class="entry code"><span class="entry-timestamp">00:17</span> <span class="entry-type">&gt;</span> <span class="entry-content">use chi for routing instead</span></span><span class="entry code"><span class="entry-timestamp">00:40</span> <span class="entry-type">&gt;</span> <span class="entry-content">use templ for the routes list rendering in <tt>http/serve.go</tt> and make it skip routes with vars i.e. {} chars</span></span><span class="entry code"><span class="entry-timestamp">00:41</span> <span class="entry-type">&gt;</span> <span class="entry-content">make a common root template in <tt>http/root.templ</tt> with dark mode, good typography, etc, keep it simple</span></span><span class="entry code"><span class="entry-timestamp">00:43</span> <span class="entry-type">&gt;</span> <span class="entry-content">move the calls to tts.Routes and aiderdoc.Routes to <tt>main.go</tt> to avoid import loop</span></span><div class="date">Monday, 5 August</div><span class="entry code"><span class="entry-timestamp">01:48</span> <span class="entry-type">&gt;</span> <span class="entry-content">make the aiderdoc package parse <tt>backtick</tt> to render as &lt;tt&gt;</span></span><span class="entry code"><span class="entry-timestamp">01:50</span> <span class="entry-type">&gt;</span> <span class="entry-content">/v</span></span><span class="entry code"><span class="entry-timestamp">01:50</span> <span class="entry-type">&gt;</span> <span class="entry-content">don&#39;t use the raw function, just like have the process thing create a structure that consists of spans, you know, so that you can have backtick spans</span></span><span class="entry code voice"><span class="entry-timestamp">01:54</span> <span class="entry-type">&gt;</span> <span class="entry-content">ok, make it also, like you can use regular expressions for this, make it so that it also creates monospace spans for words that contain underscores, words that are in camel case</span></span><span class="entry code voice"><span class="entry-timestamp">01:55</span> <span class="entry-type">&gt;</span> <span class="entry-content">the backtick thing doesn&#39;t work right now, after that change also, it seems like there&#39;s two spaces between the words, somehow</span></span><span class="entry code voice"><span class="entry-timestamp">01:58</span> <span class="entry-type">&gt;</span> <span class="entry-content">I think it&#39;ll be more reliable in process backticks to just split the whole string on the space and then deal with each word separately</span></span><span class="entry code voice"><span class="entry-timestamp">02:00</span> <span class="entry-type">&gt;</span> <span class="entry-content">ok, now also turn words that look like filenames into monospace, that means, you know, they contain a dot and then an extension or a slash</span></span><span class="entry code voice"><span class="entry-timestamp">02:25</span> <span class="entry-type">&gt;</span> <span class="entry-content">ok, now in the parser, look for lines that start with slash ask or slash run also look for the lines that consist only of slash undo or slash clear for those, like undo and clear we can show them as like some kind of small caps and for the ask and run, we show them in some kind of special way too</span></span><span class="entry code voice"><span class="entry-timestamp">02:26</span> <span class="entry-type">&gt;</span> <span class="entry-content">oh sorry, that&#39;s not the prefix of the line itself, it&#39;s the prefix of the content of a line that starts with plus</span></span><span class="entry code voice"><span class="entry-timestamp">02:49</span> <span class="entry-type">&gt;</span> <span class="entry-content">add a similar handler, handling for slash add, followed by filenames, you know</span></span><span class="entry code voice"><span class="entry-timestamp">02:57</span> <span class="entry-type">&gt;</span> <span class="entry-content">let&#39;s change the structure of the HTML so that all the lines are in a big table so, you know, the timestamp is in one column and then the line type, entry type or whatever and then the content, that&#39;s great, right?</span></span><span class="entry code voice"><span class="entry-timestamp">16:02</span> <span class="entry-type">&gt;</span> <span class="entry-content">Okay, can you make the eiderdok parser recognize when I&#39;ve typed slash voice in one line, then that means that the next line that you see will be voice input, so you should mark that up as a voice message or whatever</span></span><span class="entry code voice"><span class="entry-timestamp">16:07</span> <span class="entry-type">&gt;</span> <span class="entry-content">could you also see when I type slash chat-mode ask or chat-mode code, that switches the chat mode, so you need to keep track of what is the current chat mode set by that parameter and that also, I don&#39;t know, I mean, I guess that also applies for voice inputs, so if the chat mode is ask and I do a voice input, then that&#39;s like a voice ask or whatever, but I don&#39;t think that&#39;s the way we should show it I think we should show, you know, like right now you made it like blue and italics and you put a thing that says voice in the row, type, column or whatever, I think, let&#39;s use the style of the text to show whether it&#39;s voice or typing and let&#39;s have just like the column say just code or ask or run or whatever</span></span><span class="entry code voice"><span class="entry-timestamp">16:10</span> <span class="entry-type">&gt;</span> <span class="entry-content">all right that is pretty good, but let&#39;s not use so much color in the text, let&#39;s instead maybe use like emoji icons, so yeah, emoji icons and also some font difference, like, yeah, I mean I think maybe we could use monospace font for keyboard input and the sans-serif font for voice input, and not so many colors yeah, let&#39;s try that</span></span><span class="entry code voice"><span class="entry-timestamp">16:16</span> <span class="entry-type">&gt;</span> <span class="entry-content">Okay, let&#39;s try something a bit different We now have this table Layout, which is quite good, but I want to try something different and that is Okay, so we have this structure where there&#39;s like two levels of a hierarchy I think The first grouping is called sections, and that&#39;s like everything like When you don&#39;t have a pause in this input for 20 minutes or something, I don&#39;t remember but so what I&#39;m thinking about the layout is We don&#39;t use a table anymore, we change it so There&#39;s like a vertical list with flexbox or whatever Articles or whatever But then within each article there are these the sections The second so they would also be vertically Laid out, but within each section each entry in the section should be Like the section should be a flexbox Like a flexbox row with flex wrap So that each entry is like a little almost like a span within a flex wrap or maybe even don&#39;t use flexbox just literally use a paragraph and spans inside and Don&#39;t show the timestamps within Like don&#39;t show a timestamp for each entry show only timestamp At the beginning of each such section so then Every entry is just a span that you know participates in the normal Line breaking Algorithm of flowing text content But When you have Yeah, but they still look a bit Distinct like maybe I mean maybe using those emoji prefixes is still a good thing So something like that maybe you see what I mean</span></span><span class="entry code voice"><span class="entry-timestamp">16:37</span> <span class="entry-type">&gt;</span> <span class="entry-content">can you make it so that we&#39;re currently splitting up the sections based on only the timing but can you split this section based on also like if you switch to ask mode from code mode or vice versa then also change I like also make a new section and then I think we shouldn&#39;t show like in each section we shouldn&#39;t show the little tag that says code everywhere before each entry so let&#39;s just omit that and so okay now like when I have typed slash clear for example in the HTML I see clear and then an icon and then clear again that&#39;s not necessary so I think we shouldn&#39;t like show those tags or we shouldn&#39;t show the entry content for commands like clear but when we add we should show for add and drop and run we should show that tag and we shouldn&#39;t show the icon that depends on keyboard or voice because those commands are only possibly a keyboard and it doesn&#39;t really matter whether yeah</span></span><span class="entry code voice"><span class="entry-timestamp">16:56</span> <span class="entry-type">&gt;</span> <span class="entry-content">actually let&#39;s remove the whole thing about having the DOM structure of sections we don&#39;t need that let&#39;s just have the articles</span></span><span class="entry code"><span class="entry-timestamp">18:14</span> <span class="entry-type">&gt;</span> <span class="entry-content">how would you in the css make it so that on wider displays it goes into a mode where the height is 100vh and then the entries flow downward but also go right in columns</span></span><span class="entry code voice"><span class="entry-timestamp">20:14</span> <span class="entry-type">&gt;</span> <span class="entry-content">use the new css feature for scrolling scroll snap or whatever for the columns</span></span><span class="entry"><span class="entry-timestamp">20:15</span> <span class="entry-type">undo</span> </span><span class="entry"><span class="entry-timestamp">20:20</span> <span class="entry-type">+</span> <span class="entry-content"><tt>http/root.templ</tt></span></span><span class="entry code voice"><span class="entry-timestamp">20:20</span> <span class="entry-type">&gt;</span> <span class="entry-content">look at the css variables and stuff that we had in the root template and consider using them in the either doc template especially to get the dark mode colors good again</span></span><span class="entry"><span class="entry-timestamp">20:26</span> <span class="entry-type">$</span> <span class="entry-content">make test</span></span><span class="entry code"><span class="entry-timestamp">20:29</span> <span class="entry-type">&gt;</span> <span class="entry-content">make a folder called docs or whatever is normal for github pages content and make a make target that renders the aider html and puts it in like <tt>/docs/devlog/index.html</tt></span></span><span class="entry"><span class="entry-timestamp">20:30</span> <span class="entry-type">+</span> <span class="entry-content"><tt>main.go</tt></span></span><span class="entry code"><span class="entry-timestamp">20:30</span> <span class="entry-type">&gt;</span> <span class="entry-content">run <tt>main.go</tt> with the command for this, there&#39;s no <tt>aiderdoc/main.go</tt></span></span><span class="entry"><span class="entry-timestamp">20:31</span> <span class="entry-type">undo</span> </span></body></html>