package templates

import (
	"context"
	"fmt"
	"io"
	"jamie/db"
)

type PacketViewModel struct {
	SampleIdx         int64
	RelativeSampleIdx int64
	Timestamp         string
	Duration          string
}

type RecognitionViewModel struct {
	SampleIdx         int64
	RelativeSampleIdx int64
	Timestamp         string
	Duration          string
	Text              string
	SampleLen         int64
}

type DebugViewModel struct {
	Stream       db.Stream
	Packets      []PacketViewModel
	Recognitions []RecognitionViewModel
	EndSample    int64
}

templ Debug(viewModel DebugViewModel) {
	@layout("Debug View - Stream " + viewModel.Stream.ID) {
		<h1>Debug View - Stream { viewModel.Stream.ID }</h1>
		<h2>Stream Details</h2>
		<table>
			<tr><th>ID</th><td>{ viewModel.Stream.ID }</td></tr>
			<tr><th>Packet Seq Offset</th><td>{ fmt.Sprintf("%d", viewModel.Stream.PacketSeqOffset) }</td></tr>
			<tr><th>Sample Idx Offset</th><td>{ fmt.Sprintf("%d", viewModel.Stream.SampleIdxOffset) }</td></tr>
			<tr><th>Created At</th><td>{ fmt.Sprintf("%f", viewModel.Stream.CreatedAt) }</td></tr>
			<tr><th>Ended At</th><td>{ fmt.Sprintf("%f", viewModel.Stream.EndedAt.Float64) }</td></tr>
		</table>
		<h2>Timeline</h2>
		<svg width="100%" height="100" style="border: 1px solid #ccc;">
			@timelineSVG(viewModel)
		</svg>
		<h2>Packets</h2>
		<table>
			<tr>
				<th>Sample Index</th>
				<th>Relative Sample Index</th>
				<th>Duration</th>
				<th>Timestamp</th>
			</tr>
			for _, packet := range viewModel.Packets {
				<tr>
					<td>{ fmt.Sprintf("%d", packet.SampleIdx) }</td>
					<td>{ fmt.Sprintf("%d", packet.RelativeSampleIdx) }</td>
					<td>{ packet.Duration }</td>
					<td>{ packet.Timestamp }</td>
				</tr>
			}
		</table>
		<h2>Recognitions</h2>
		<table>
			<tr>
				<th>Sample Index</th>
				<th>Relative Sample Index</th>
				<th>Duration</th>
				<th>Timestamp</th>
				<th>Text</th>
			</tr>
			for _, recognition := range viewModel.Recognitions {
				<tr>
					<td>{ fmt.Sprintf("%d", recognition.SampleIdx) }</td>
					<td>{ fmt.Sprintf("%d", recognition.RelativeSampleIdx) }</td>
					<td>{ recognition.Duration }</td>
					<td>{ recognition.Timestamp }</td>
					<td>{ recognition.Text }</td>
				</tr>
			}
		</table>
	}
}

templ timelineSVG(viewModel DebugViewModel) {
	@timelinePackets(viewModel)
	@timelineRecognitions(viewModel)
}

templ timelinePackets(viewModel DebugViewModel) {
	if len(viewModel.Packets) > 0 {
		@mergeConsecutivePackets(viewModel)
	}
}

templ timelineRecognitions(viewModel DebugViewModel) {
	if len(viewModel.Recognitions) > 0 {
		@mergeConsecutiveRecognitions(viewModel)
	}
}

func mergeConsecutivePackets(viewModel DebugViewModel) templ.Component {
	return templ.ComponentFunc(func(ctx context.Context, w io.Writer) (err error) {
		startIdx := viewModel.Packets[0].SampleIdx
		for i := 1; i < len(viewModel.Packets); i++ {
			if viewModel.Packets[i].SampleIdx-viewModel.Packets[i-1].SampleIdx > 960 {
				err = drawPacketRect(viewModel, startIdx, viewModel.Packets[i-1].SampleIdx).Render(ctx, w)
				if err != nil {
					return err
				}
				startIdx = viewModel.Packets[i].SampleIdx
			}
		}
		return drawPacketRect(viewModel, startIdx, viewModel.Packets[len(viewModel.Packets)-1].SampleIdx).Render(ctx, w)
	})
}

func drawPacketRect(viewModel DebugViewModel, startIdx, endIdx int64) templ.Component {
	x := fmt.Sprintf("%.2f%%", float64(startIdx-viewModel.Stream.SampleIdxOffset)/float64(viewModel.EndSample-viewModel.Stream.SampleIdxOffset)*100)
	width := fmt.Sprintf("%.2f%%", float64(endIdx-startIdx)/float64(viewModel.EndSample-viewModel.Stream.SampleIdxOffset)*100)
	return templ.ComponentFunc(func(ctx context.Context, w io.Writer) (err error) {
		_, err = io.WriteString(w, fmt.Sprintf(`<rect x="%s" y="0" width="%s" height="45" fill="blue" opacity="0.5" />`, x, width))
		return err
	})
}

func mergeConsecutiveRecognitions(viewModel DebugViewModel) templ.Component {
	return templ.ComponentFunc(func(ctx context.Context, w io.Writer) (err error) {
		startIdx := viewModel.Recognitions[0].SampleIdx
		endIdx := startIdx + viewModel.Recognitions[0].SampleLen
		text := viewModel.Recognitions[0].Text
		for i := 1; i < len(viewModel.Recognitions); i++ {
			if viewModel.Recognitions[i].SampleIdx > endIdx {
				err = drawRecognitionRect(viewModel, startIdx, endIdx, text).Render(ctx, w)
				if err != nil {
					return err
				}
				startIdx = viewModel.Recognitions[i].SampleIdx
				text = viewModel.Recognitions[i].Text
			} else {
				text += " " + viewModel.Recognitions[i].Text
			}
			endIdx = viewModel.Recognitions[i].SampleIdx + viewModel.Recognitions[i].SampleLen
		}
		return drawRecognitionRect(viewModel, startIdx, endIdx, text).Render(ctx, w)
	})
}

func drawRecognitionRect(viewModel DebugViewModel, startIdx, endIdx int64, text string) templ.Component {
	x := fmt.Sprintf("%.2f%%", float64(startIdx-viewModel.Stream.SampleIdxOffset)/float64(viewModel.EndSample-viewModel.Stream.SampleIdxOffset)*100)
	width := fmt.Sprintf("%.2f%%", float64(endIdx-startIdx)/float64(viewModel.EndSample-viewModel.Stream.SampleIdxOffset)*100)
	return templ.ComponentFunc(func(ctx context.Context, w io.Writer) (err error) {
		_, err = io.WriteString(w, fmt.Sprintf(`<g><rect x="%s" y="50" width="%s" height="45" fill="green" opacity="0.5"><title>%s</title></rect></g>`, x, width, text))
		return err
	})
}
